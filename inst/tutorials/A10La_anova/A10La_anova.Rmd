---
title: "ANOVA"
author: "Guyliann Engels & Philippe Grosjean"
description: "**SDD I Module 10** ANOVA et tests post-hoc."
tutorial:
  id: "A10La_anova"
  version: 2.0.0/10
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---


```{r setup, include=FALSE}
BioDataScience1::learnr_setup()
SciViews::R()
```

```{r, echo=FALSE}
BioDataScience1::learnr_banner()
```

```{r, context="server"}
BioDataScience1::learnr_server(input, output, session)
```

----

## Objectifs

Vous avez d√©couvert il y a peu la moyenne et plusieurs tests d'hypoth√®ses associ√©s (diff√©rentes variantes du test *t* de Student). Le test *t* de Student ind√©pendant vous permet de comparer les moyennes de deux populations.

Le [module 10](https://wp.sciviews.org/sdd-umons/?iframe=wp.sciviews.org/sdd-umons-2020/variance.html) du cours vous explique pourquoi c'est une mauvaise id√©e de l'appliquer pour comparer plus de deux moyennes simultan√©ment via des comparaisons deux √† deux multiples sans pr√©cautions particuli√®res.

![](images/red-traffic-lights.png){width='10%'}

L'analyse de variance (ANOVA) est, par contre, toute indiqu√©e pour comparer les moyennes de plus de deux populations simultan√©ment.

![](images/green-traffic-lights.png){width='10%'}

Dans ce tutoriel, vous allez pouvoir auto-√©valuer votre capacit√© √†\ :

- r√©aliser des graphiques relatifs √† la distribution F

- effectuer une analyse de variance (ANOVA) et l'interpr√©ter correctement

- recourir √† un test post-hoc de comparaison multiples pour pr√©ciser les diff√©rences de moyennes en cas de rejet de H~0~ de l'ANOVA

## Distribution F

La loi de distribution th√©orique sur laquelle l'ANOVA se base est la distribution F de Fisher-Snedecor. C'est une distribution asym√©trique d'une allure similaire √† la distribution du Chi^2^. Cependant, les param√®tres diff√®rent. La question suivante vous permet de v√©rifier si vous avez bien compris √† quoi correspondent les deux param√®tres de la distribution F.

Tracez le graphique de densit√© de probabilit√© de la distribution F qui correspond √† l'analyse d'un √©chazntillon de  100 observations r√©parties en 5 groupes (comparaison de 5 moyennes).

üí¨ **Ce code correspond au snippet `.ifdens`**

```{r fplot_h2, exercise=TRUE, exercise.lines=10}
# Fisher-Snedecor's F distribution (density probability) with parameter:
.df1 <- ___; .df2 <- ___ # numerator (.df1) and denominator (.df2) df
.col <- 1; .add <- FALSE # Plot parameters
.x <- seq(0, qf(0.999, df1 = .df1, df2 = .df2), l = 1000)  # Quantiles
.d <- function (x) df(x, df1 = .df1, df2 = .df2)           # Distribution function
.q <- function (p) qf(p, df1 = .df1, df2 = .df2)           # Quantile for lower-tail prob
.label <- bquote(F(.(.df1), .(.df2)))                      # Curve parameters
curve(.d(x), xlim = range(.x), xaxs = "i", n = 1000, col = .col,
  add = .add, xlab = "Quantiles", ylab = "Probability density") # Curve
abline(h = 0, col = "gray") # Baseline
```

```{r fplot_h2-hint-1}
# Fisher-Snedecor's F distribution (density probability) with parameter:
.df1 <- 4; .df2 <- ___ # numerator (.df1) and denominator (.df2) df
.col <- 1; .add <- FALSE # Plot parameters
.x <- seq(0, qf(0.999, df1 = .df1, df2 = .df2), l = 1000)  # Quantiles
.d <- function (x) df(x, df1 = .df1, df2 = .df2)           # Distribution function
.q <- function (p) qf(p, df1 = .df1, df2 = .df2)           # Quantile for lower-tail prob
.label <- bquote(F(.(.df1), .(.df2)))                      # Curve parameters
curve(.d(x), xlim = range(.x), xaxs = "i", n = 1000, col = .col,
  add = .add, xlab = "Quantiles", ylab = "Probability density") # Curve
abline(h = 0, col = "gray") # Baseline

 #### ATTENTION: Hint suivant = solution !####
```

```{r fplot_h2-solution}
# Fisher-Snedecor's F distribution (density probability) with parameter:
.df1 <- 4; .df2 <- 95 # numerator (.df1) and denominator (.df2) df
.col <- 1; .add <- FALSE # Plot parameters
.x <- seq(0, qf(0.999, df1 = .df1, df2 = .df2), l = 1000)  # Quantiles
.d <- function (x) df(x, df1 = .df1, df2 = .df2)           # Distribution function
.q <- function (p) qf(p, df1 = .df1, df2 = .df2)           # Quantile for lower-tail prob
.label <- bquote(F(.(.df1), .(.df2)))                      # Curve parameters
curve(.d(x), xlim = range(.x), xaxs = "i", n = 1000, col = .col,
  add = .add, xlab = "Quantiles", ylab = "Probability density") # Curve
abline(h = 0, col = "gray") # Baseline
```

```{r fplot_h2-check}
grade_code("Le code pour obtenir ce graphique est un peu long... mais le snippet est l√† pour vous pr√©remplir la majeure partie ! Vous avez cependant su convertir le nombre d'observations et le nombre de groupes en degr√©s de libert√© intragroupe et intergroupe.", "Il semble que vous n'avez pas su d√©terminer correctement les param√®tres de la distribution F. Si n correspond au nombre d'observations et k au nombre de groupes, alors le nombre de degr√©s intergroupe vaut k ‚Äì 1  et le nombre de degr√©s intragroupe vaut n ‚Äì k.")
```

## Croissance des dents de cochons d'Inde

Vous allez maintenant r√©aliser une analyse compl√®te de l'effet de la vitamine C sur la longueur des odontoblastes (cellules responsables de la croissance et de la formation de l'√©mail des dents) de cochons d'Inde. Les donn√©es utilis√©es proviennent du jeu de donn√©es `ToothGrowth` du package `datasets` (vous pouvez donc consulter la page d'aide si vous souhaitez obtenir plus d'informations).

![](images/guinea-pig.jpg){width='50%'}

Le jeu de donn√©es comprend les variables suivantes\ :

```{r, echo=TRUE}
# importation
toothgrowth <- read("ToothGrowth", package = "datasets", lang = "fr")
# Quelques informations sur le tableau de donn√©es.
glimpse(toothgrowth)
```

- `len`\ : longueur des odontablastes (¬µm)
- `supp`\ : suppl√©ment administr√©, OJ (jus d'orange contenant donc entre autres de la vitamine C) ou VC (vitamine C sous forme d'acide ascorbique)
- `dose`\ : dose de vitamine C administr√©e en trois rations diff√©rentes, 0.5, 1 et 2 mg/J

```{r, echo=TRUE}
# V√©rification des types des variables et ajout des labels
toothgrowth %>.%
  mutate(., 
    supp = factor(supp, levels = c("OJ", "VC")),
    dose = ordered(dose, levels = c(0.5, 1, 2))) %>.%
  labelise(toothgrowth, self = FALSE,
    label = list(
      len = "Longueur des odontoblastes",
      supp = "Suppl√©mentation",
      dose = "Dose de vitamine C"),
    units = list(
      len = "¬µm",
      supp = NA,
      dose = "mg/J"
      )
    ) -> toothgrowth
```

**Cette √©tape est la premi√®re √† r√©aliser apr√®s avoir import√© les donn√©es. Il faut v√©rifier et adapter les types et les labels des variables.** Il est particuli√®rement important que les variables qui d√©finissent les sous-populations compar√©es soient bien encod√©es sous forme d'objets `factor` ou `ordered`\ ! Le pi√®ge lorsqu'il s'agit de valeurs num√©riques, comme ici, est de laisser la variable sous forme `integer` ou `numeric`, car alors, la fonction `lm()` fera une autre analyse (r√©gression lin√©aire que nous verrons au cours SDD II).

Nous allons nous concentrer uniquement sur les individus qui ont re√ßu de la vitamine C. La question biologique est la suivante : **y a t'il une diff√©rence de la longueur des odontoblastes en fonction de la ration journali√®re de vitamine C administr√©e\ ?**

```{r, echo=TRUE}
tooth_vc <- filter(toothgrowth, supp == "VC")
```

### Description des donn√©es

Rappelez-vous que la description des donn√©es est une √©tape indispensable avant leur analyse (voir modules [2](https://wp.sciviews.org/sdd-umons/?iframe=wp.sciviews.org/sdd-umons-2020/visu1.html), [3](https://wp.sciviews.org/sdd-umons/?iframe=wp.sciviews.org/sdd-umons-2020/visu2.html) et [4](https://wp.sciviews.org/sdd-umons/?iframe=wp.sciviews.org/sdd-umons-2020/visu3.html) de SDD I).

### Description num√©rique

R√©alisez un tableau reprenant les moyennes et les √©cart-types de la longueur des dents des cochons d'Inde pour chaque dose administr√©e en vitamine C ainsi que le nombre d'observations par groupe. Le jeu de donn√©es √† utiliser est donc `tooth_vc`.

üí¨ **Ce code correspond au snippet `.hmanova1desc`**

```{r tg_prepare}
toothgrowth <- read("ToothGrowth", package = "datasets", lang = "fr")
toothgrowth$dose <- as.ordered(toothgrowth$dose)

toothgrowth <- labelise(toothgrowth, self = FALSE,
  label = list(
    len = "Longueur des odontaoblastes",
    supp = "Suppl√©mentation",
    dose = "Dose de vitamine C"
  ),
  units = list(
    len = "¬µm",
    supp = NA,
    dose = "mg/J"
  )
)

tooth_vc <- filter(toothgrowth, supp == "VC")

tooth_vc <- labelise(tooth_vc, self = FALSE,
  label = list(
    len = "Longueur des odontoblastes",
    supp = "Suppl√©mentation",
    dose = "Dose de vitamine C"
  ),
  units = list(
    len = "¬µm",
    supp = NA,
    dose = "mg/J"
  )
)

anova. <- lm(data = tooth_vc, len ~ dose)
```

```{r tooth_tab_h2, exercise=TRUE, exercise.lines=4, exercise.setup="tg_prepare"}
___ %>.%
  group_by(., ___) %>.%
  summarise(., moyenne = ___(___), `√©cart type` = ___(___),
    n = sum(!is.na(___)))
```

```{r tooth_tab_h2-hint-1}
tooth_vc %>.%
  group_by(., ___) %>.%
  summarise(., moyenne = mean(___), `√©cart type` = sd(___),
    n = sum(!is.na(___)))

 #### ATTENTION: Hint suivant = solution !####
```

```{r tooth_tab_h2-solution}
tooth_vc %>.%
  group_by(., dose) %>.%
  summarise(., moyenne = mean(len), `√©cart type` = sd(len),
    n = sum(!is.na(len)))
```

```{r tooth_tab_h2-check}
grade_code("Vous obtenez le tableau ad√©quat en vue de r√©aliser ensuite une ANOVA : les moyennes correspondent √† ce que nous comparons, les √©cart-types indiquent la dispersion des donn√©es dans chaque sous-population et le nombre d'observations permet de cerner la quantit√© d'informations disponibles.")
```

### Description graphique

Plusieurs graphiques diff√©rents permettent de visualiser correctement vos observations avant de r√©aliser une ANOVA. Employez ici les bo√Ætes de dispersion parall√®les.

üí¨ **Ce code correspond au snippet `.cbbox`**

```{r tooth_graph, exercise = TRUE, exercise.setup = "tg_prepare"}
chart(data = ___, ___ ~ ___) +
  geom____()
```

```{r tooth_graph-solution}
chart(data = tooth_vc, len ~ dose) +
  geom_boxplot()
```

```{r tooth_graph-check}
grade_code("Vous obtenez le graphique ad√©quat qui permet de comparer la longueur des dents en fonction de la dose administr√©e. Notez toutefois que la boite de dispersion pr√©sente la m√©diane √† la place de la moyenne. Ce graphique est donc, sans doute plus adapt√© au test de Kruskal-Wallis. Voyez dans le cours les autres graphiques qui comparent les moyennes pour des versions alternatives int√©ressantes dans le cas de l'ANOVA.")
```

Maintenant que vous avez pris connaissance de vos donn√©es gr√¢ce √† un tableau et un graphique, vous pouvez r√©aliser votre test d'hypoth√®se... mais avant cela, assurez-vous que les conditions d'application du test sont respect√©es.

### V√©rification des conditions d'applications

Pour r√©aliser une ANOVA, il faut respecter les conditions d'application suivantes\ :

- √©chantillon repr√©sentatif (par exemple, al√©atoire),
- observations ind√©pendantes,
- variable dite r√©ponse quantitative,
- une variable dite explicative qualitative √† trois niveaux ou plus,
- distribution Normale des r√©sidus,
- homosc√©dasticit√© (m√™me variance intragroupe).

Pour les deux premi√®res conditions, vous lisez attentivement le protocole exp√©rimental pour voir si l'√©chantillonnage est repr√©sentatif et les observations sont ind√©pendantes les unes des autres. Il faut un processus al√©atoire qui intervienne dans la s√©lection des individus dans l'exp√©rience et pour leur attribution √† un des niveaux (ration de vitamine C quotidienne). Chaque individu doit avoir une chance √©gale d'√™tre tir√© au sort. Il ne doit pas y avoir de d√©pendance (par exemple, utiliser une port√©e de cobayes au sein d'une m√™me sous-population est une mauvaise id√©e car la ressemblance g√©n√©tique entre fr√®res et s≈ìurs rend les observations partiellement d√©pendantes entre elles).

Les contraintes relatives au type de variables en jeu se v√©rifient facilement. Nous insistons encore une fois sur la n√©cessit√© de s'assurer que la variable explicative (celle qui s√©pare l'√©chantillon en sous-populations) soit bien qualitative, donc un objet `factor` ou `ordered` dans R.

Les deux derni√®res conditions **doivent √™tre v√©rifi√©es sur les donn√©es de l'√©chantillon**. Si les donn√©es sont en nombre suffisant, soit au moins une petite dizaine par sous-population, nous pourrons appliquer un test d'homog√©n√©it√© de variance et comparer la distribution des r√©sidus du mod√®le √† une distribution Normale. Nous sommes dans cette situation. Si le nombre d'observations est trop faible, il faut le tester ou l'avoir test√© pr√©c√©demment sur un plus gros √©chantillon similaire, ou se rabattre sur un test non param√©trique (Kruskal-Wallis) en cas de doute. Rappelons aussi qu'il est possible de tester des transformations des donn√©es, si l'une ou les deux conditions ne sont pas rencontr√©es.

En pratique, on commence par v√©rifier l'homosc√©dasticit√©, puis on r√©alise notre ANOVA et ensuite on v√©rifie la distribution Normale des r√©sidus. La raison qui nous pousse √† postposer la v√©rification de la Normalit√© des r√©sidus sera r√©alis√©e plus loin dans ce tutoriel.

### Test de Bartlett

Il existe plusieurs tests qui permettent de v√©rifier l'homosc√©dasticit√©. Nous vous proposons d'utiliser le test de Bartlett. Avant de foncer dans la zone de code R, r√©fl√©chissez √† l'hypoth√®se nulle et √† l'hypoth√®se alternative de ce test. Cela doit √™tre clair dans votre esprit, sans quoi vous serez incapable d'interpr√©ter correctement le test.

üí¨ **Ce code correspond au snippet `.hvbartlett`**

```{r tooth_bart, exercise = TRUE, exercise.setup = "tg_prepare"}
bartlett.test(data = ___, ___ ~ ___)
```

```{r tooth_bart-solution}
bartlett.test(data = tooth_vc, len ~ dose)
```

```{r tooth_bart-check}
grade_code("vous avez entr√© l'instruction correcte. Le plus important est encore √† faire. R√©pondez donc √† la question suivante.")
```

```{r bart_quiz1}
question("Y a t'il homosc√©dasticit√© (√©galit√© des variances entre sous-populations) ici si vous choisissez 5% comme seuil alpha ?",
  answer("oui", correct = TRUE),
  answer("non"),
  correct = "Super, vous avez pu correctement analyser les r√©sultats de ce test. ",
  incorrect = "Il semble que vous n'avez pas bien compris la notion d'homosc√©dasticit√© ou que vous n'avez pas pu d√©finir correctement les hypoth√®ses H0 et H1 du test de Bartlett.",
  allow_retry = TRUE)
```

## ANOVA

Dans R, nous avons plusieurs fonctions pour r√©aliser une ANOVA. Nous utilisons `lm()` qui demande un jeu de donn√©es et une formule. Nous luio- appliquons la m√©thode `anova()` pour produire le tableau de l'analyse de la variance.

```{r, echo=TRUE, eval=FALSE}
anova(anova. <- lm(data = DF, YNUM ~ XFACTOR))
```

Vous √™tes habitu√© √† cet interface formule que vous utilisez dans la r√©alisation de vos graphiques ou de vos tests d'hypoth√®se pr√©c√©dents. Cette fonction calcule un objet de classe `lm` duquel la fonction `anova()` va extraire l'information qui nous int√©resse pour interpr√©ter ce test. R√©alisez votre mod√®le ANOVA sur la longueur des odontoblastes en fonction de la dose de vitamine C administr√©e.

üí¨ **Ce code correspond au snippet `.hmanova1`**

```{r tooth_anova_h2, exercise = TRUE, exercise.setup = "tg_prepare"}
anova(anova. <- lm(data = ___, ___ ~ ___))
```

```{r tooth_anova_h2-hint-1}
anova(anova. <- lm(data = tooth_vc, ___ ~ ___))

#### ATTENTION: Hint suivant = solution !####
```

```{r tooth_anova_h2-solution}
anova(anova. <- lm(data = tooth_vc, len ~ dose))
```

```{r tooth_anova_h2-check}
grade_code("Vous avez compris le principe. Mais attention : n'allez pas plus loin dans l'interpr√©tation des r√©sultats sans avoir v√©rifi√© la Normalit√© des r√©sidus.")
```

V√©rifiez maintenant la distribution Normale des r√©sidus de mod√®le `.anova`

üí¨ **Il existe une snippet pour vous aider `.hmanovaqqplot`**

```{r tooth_qqplot_h2, exercise = TRUE, exercise.setup = "tg_prepare"}
plot(___, ___ = ___)
```

```{r tooth_qqplot_h2-hint-1}
plot(___, which = 2)

#### ATTENTION: Hint suivant = solution !####
```

```{r tooth_qqplot_h2-solution}
plot(anova., which = 2)
```

```{r tooth_qqplot_h2-check}
grade_code("Tous les points de ce graphique quantile-quantile s'alignent assez bien le long de la droite. Les r√©sidus du mod√®le ne montrent donc pas de d√©rive importante par rapport √† une distribution Normale et nous avons r√©uni toutes les conditions d'application de l'ANOVA. Vous pouvez maintenant interpr√©ter votre test (tableau d'analyse de la variance) que vous avez r√©alis√© dans l'exercice pr√©c√©dent.")
```

```{r anova_quiz}
question("Y a t'il un effet significatif de la dose de vitamine C administr√©e sur la longueur des odontoblastes au seuil alpha de 5% ?",
  answer("oui", correct = TRUE),
  answer("non"),
  correct = "Excellent ! Vous avez correctement analys√© votre tableau de l'analyse de la variance. L'ANOVA vous permet de savoir qu'au moins un des groupes diff√®re des autres. Vous allez devoir r√©aliser une analyse compl√©mentaire pour d√©terminer la ou les moyennes qui diff√®re(nt) des autres.",
  incorrect = "Il semble que vous avez mal interpr√©t√© votre ANOVA. Allez revoir la r√®gle de d√©cision bas√©e sur la comparaison de la valeur P d'un test au seuil alpha fix√©.",
  allow_retry = TRUE)
```

## Tests post-hoc

Votre ANOVA indique donc qu'il y a au moins une des moyennes qui est significativement diff√©rente des autres au seuil $\alpha$ de 5%. Un test post-hoc de comparaisons multiples va vous permettre de pr√©ciser cela. **Attention\ : ce genre de test est con√ßus pour √™tre fiable uniquement lorsque H~0~ est rejet√©e pour l'ANOVA.** Ne l'utilisez pas *avant* d'avoir fait votre ANOVA, ni lorsque H~0~ n'est *pas* rejet√©e\ !

üí¨ **Ce code correspond au snippet `.hmanovamult`**

```{r tooth_post, exercise = TRUE, exercise.setup = "tg_prepare"}
summary(anovaComp. <- confint(multcomp::glht(anova.,
  linfct = multcomp::mcp(___ = "Tukey")))) # Add a second factor if you want
.oma <- par(oma = c(0, 5.1, 0, 0)); plot(anovaComp.); par(.oma); rm(.oma)
```

```{r tooth_post-solution}
summary(anovaComp. <- confint(multcomp::glht(anova.,
  linfct = multcomp::mcp(dose = "Tukey")))) # Add a second factor if you want
.oma <- par(oma = c(0, 5.1, 0, 0)); plot(anovaComp.); par(.oma); rm(.oma)
```

```{r tooth_post-check}
grade_code("Avec l'aide des snippets, il est relativement simple de r√©aliser un test post-hoc. Le graphique montre une comparaison deux √† deux des diff√©rentes moyennes (pour la comparaison i - j, moyenne_i - moyenne_j) avec un correction via la m√©thode HSD de Tukey pour √©viter l'inflation de l'erreur.")
```

```{r post_quiz}
question("Quels sont les niveaux significativement diff√©rents au seuil alpha de 5% ?",
         answer("0.5 par rapport √† 1", correct = TRUE),
         answer("0.5 par rapport √† 2", correct = TRUE),
         answer("1 par rapport √† 2", correct = TRUE), 
  allow_retry = TRUE, correct = "Superbe ! Les trois moyennes sont toutes diff√©rentes les uns des autres ici. Les intervalles sur le graphique ne contiennent jamais z√©ro.",
  incorrect = "Votre r√©ponse est probablement incompl√®te. Pour une premi√®re analyse, regardez bien le tableau et le graphique issus de l'analyse post hoc.")
```

## Interpr√©tation biologique

Notre ANOVA est termin√©e. Il nous reste √† int√©grer ces r√©sultats dans notre document. Rappelez-vous que la formulation est importante. Vous utiliserez une phrase du genre\ : chez le cochon d'Inde, la longueur des odontoblastes s'accro√Æt de mani√®re significative au seuil $\alpha$ de 5% avec une augmentation de la ration quotidienne de vitamine C de 0.5 √† 1, et √† 2 mg/J (ANOVA √† 2 et 27 ddl, F = 67,1, valeur P < 3,3‚Ä¢10^-11^ ; voir aussi tests post-hoc de Tukey Table X et Fig. Y). Vous discuterez ensuite des m√©canismes qui entrent possiblement en jeu ici, en r√©fl√©chissant au r√¥le de l'acide ascorbique dans les r√©actions biochimiques de formation de la dentine et de l'√©mail, par exemple.

Comme la formulation du test dans la parenth√®se est fort longue pour l'ANOVA, on utilise souvent un renvoi vers la Table de l'analyse de la variance qui est int√©gr√©e dans le document pour plus de lisibilit√© √† la fois du texte et du r√©sultat de l'ANOVA. Naturellement, si un test post-hoc est r√©alis√©, il doit aussi √™tre int√©gr√© soit sous forme de tableau, soit sous forme de graphique, ou encore les deux si la place dans le document le permet (pour les articles scientifiques on est souvent fort limit√© en nombre de figures et tables).

Dans le mat√©riel et m√©thodes, vous devez expliquer que vous r√©aliser une ANOVA apr√®s avoir v√©rifi√© les conditions d'application (homosc√©dasticit√© attest√©e √† l'aide d'un test de Bartlett au seuil $\alpha$ de 5% et Normalit√© des r√©sidus v√©rifi√©e sur un graphique quantile-quantile). Vous devez aussi indiquer la version R (et √©ventuellement la version des packages additionnel R utilis√©s). Pensez √† la fonction `sessionInfo()` pour obtenir la version de R. Il n'est pas n√©cessaire de pr√©ciser la version de RStudio qui est ici essentiellement l'interface vous permettant d'√©crire et lancer le code R de votre analyse. Par contre, si vous utilisez un environnement logiciel reproductible comme la SciViews Box, vous pouvez le pr√©ciser et en indiquer la version.

## Conclusion

Bravo! Vous venez de terminer une ANOVA compl√®te. Toutes les √©tapes de cette analyse sont importantes\ : les phases de remaniement et description des donn√©es ainsi que la v√©rification des conditions d'application du test sont trop souvent n√©glig√©es. Ne faites pas cette erreur-l√† vous-m√™me.

```{r comm_noscore, echo=FALSE}
question_text(
  "Laissez-nous vos impressions sur cet outil p√©dagogique",
  answer("", TRUE, message = "Pas de commentaires... C'est bien aussi."),
  incorrect = "Vos commentaires sont enregistr√©s.",
  placeholder = "Entrez vos commentaires ici...",
  allow_retry = TRUE
)
```
