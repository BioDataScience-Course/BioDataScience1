---
title: "Remaniement de données"
author: "Guyliann Engels & Philippe Grosjean"
description: "**SDD I Module 5** Remanier des données dans R."
tutorial:
  id: "A05La_wrangling"
  version: 2.2.0/5
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
    fig_caption: yes
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
BioDataScience1::learnr_setup()
SciViews::R(lang = "fr")
library(BioDataScience)

# Dataset
crabs <- read("crabs", package = "MASS")
```

```{r, echo=FALSE}
BioDataScience1::learnr_banner()
```

```{r, context="server"}
BioDataScience1::learnr_server(input, output, session)
```

------------------------------------------------------------------------

## Objectifs

Le cours de Science des données I : visualisation se divise en deux parties. La première partie traite principalement de la réalisation de graphiques et la seconde du remaniement des données. Ce tutoriel doit vous permettre de :

-   Vérifier l'acquisition des notions relatives aux remaniement des données avec les fonctions `select()`/`sselect()`, `filter()`/`sfilter()`, `mutate()`/`smutate()`, `group_by()`/`sgroup_by()`, `summarise()`/`ssummarise()`
-   Vérifier l'acquisition des compétences relatives au chaînage des instructions

## Les fonctions speedy/tidy

L'instruction `SciViews::R` ou `SciViews::R()` qui est équivalente, est employée afin de charger une série cohérente de packages R. Nous l'utilisons en début de script R ou encore dans le premier chunk d'un rapport d'analyse au format R Markdown.

```{r, echo=TRUE, eval=FALSE}
SciViews::R()
```

Vous employez des tableaux de données depuis le premier module de ce cours afin de réaliser des graphiques. Vous allez à présent apprendre à les manipuler. Il existe dans R plusieurs types d'objets pour traiter les tableaux de données, dont **data.frame**, tibble (objet **tbl_df**) ou **data.table**. Par défaut dans `SciViews::R`, vous travaillez avec des objets de type **data.table**. La vitesse de traitements et la gestion en mémoire des objets **data.table** en font le choix idéal pour traiter des gros jeux de données. Actuellement, vous n'avez pas encore traité des gros jeux de données mais cela va venir plus vite que vous ne l'imaginez.

Le remaniement de données est tout un art que vous devez maîtriser. Vous devez être capable de sélectionner des colonnes, de filtrer des lignes, de trier un tableau, de résumer vos observations,...

Parmi les fonctions de remaniement de tableaux, nous avons les fonctions "speedy" élaborées dans le nouveau package {svBase} sur base de travail réalisé dans le package {collapse} qui vise à accélérer le traitement dans R. Ces fonctions speedy sont compatibles avec les objets **data.table**. Elles sont préfixées avec un "s" pour les reconnaître facilement.

```{r, echo=TRUE}
list_speedy_functions()
```

Un second ensemble est constitué des fonctions "tidy" du [Tidyverse](https://www.tidyverse.org), et portant le même nom que leurs homologues speedy, mais non préfixées d'un "s".

```{r, echo=TRUE}
list_tidy_functions()
```

Nous retrouvons donc des paires de fonctions tidy/speedy qui réalisent des traitements très similaires et ont une syntaxe identique ou très proche. Elles permettent de :

-   sélectionner des colonnes d'un jeu de données avec `select()`/`sselect()`
-   filtrer des lignes dans un jeu de données avec `filter()`/`sfilter()`
-   calculer de nouvelles variables dans un jeu de données avec `mutate()`/`smutate()`
-   indiquer les variables de regroupement à utiliser dans un tableau avec `group_by()`/`sgroup_by()`
-   résumer les variables d'un jeu de données avec `summarise()`/`ssummarise()`

*Nous vous conseillons d'employer préférentiellement les fonctions speedy.* Vous trouverez un exemple d'instructions ci-dessous équivalentes et écrite d'abord sous forme speedy, et ensuite sous forme tidy.

```{r, echo=TRUE, eval=FALSE}
# Assignation classique avec fonctions "speedy" => version conseillée
crabs1 <- sselect(crabs, species, sex, length) 
# Assignation alternative avec fonctions "tidy"
crabs1 %<-% select(crabs, species, sex, length)
```

Si vous analysez ces instructions, il y a un élément qui doit vous sauter aux yeux. On peut observer une assignation particulière avec les fonctions tidy dans `SciViews::R`. En effet, il faut prendre soin de **collecter** les résultats à la fin si l'on travaille avec des objets de classe **data.table**. C'est le package {dtplyr} qui gère les calculs en interne. Utilisez l'assignation alternative `%<-%` ou `%->%`, ou alors, explicitement la fonction `collect_dtx()` pour récupérer un tableau utilisable ensuite avec les fonctions non-tidy. Par contre, une suite de fonctions tidy ne nécessite pas de collecter le tableau entre leurs appels.

```{r, echo=TRUE, eval=FALSE}
#  Assignation alternative avec fonctions "tidy"
crabs1 %<-% select(crabs, species, sex, length)
#  Assignation classique avec collect_dtx() (plus lourd) 
crabs1 <- collect_dtx(select(crabs, species, sex , length))
#  Assignation classique avec collect_dtx() et le pipe natif de R (plus lourd)
crabs1 <- (select(crabs, species, length) |> collect_dtx())
```

## Deux variétés de crabes

Le tableau de données que vous allez employer porte sur deux variétés de crabes.

```{r, echo = TRUE}
SciViews::R(lang = "fr")
# Importation des données crabs
(crabs <- read("crabs", package = "MASS"))
```

Ce tableau contient `r nrow(crabs)` observations et `r ncol(crabs)` variables. Les carapaces d'individus mâles et femelles de deux variétés de crabes ont été mesurées sous toutes les coutures.

### Calculer de nouvelles variables

Calculez sur le tableau `crabs` à l'aide de la fonction speedy `smutate()` :

-   le logarithme (`log()`) de la longueur de la carapace (`length`) des crabes et nommez cette nouvelle variables **length_log**
-   la racine carrée (`sqrt()`) de la largueur de la carapace (`width`) et nommez cette nouvelle variable **width_sqrt**
-   Divisez la variable lobe frontal (`front`) par 1000 et nommez cette nouvelle variable **front_m**

Affichez ensuite les premières lignes du tableau (`head()`). Par défaut, les 6 premières lignes sont affichées). Vous devez obtenir le tableau ci-dessous :

```{r}
crabs <- smutate(crabs, 
  length_log = log(length),
  width_sqrt = sqrt(width),
  front_m    = front / 1000)
# Visualisation des premières lignes du tableau 
head(crabs)
```

```{r mutate_h3, exercise=TRUE}
___ <- ___(___,
  ___ = ___,
  ___ = ___,
  ___ = ___)
# Visualisation des premières lignes du tableau 
___(___)
```

```{r mutate_h3-hint-1}
DF <- smutate(___,
  length_log = ___,
  width_sqrt = ___,
  front_m    = ___)
# Visualisation des premières lignes du tableau 
head(___)
```

```{r mutate_h3-hint-2}
crabs <- smutate(crabs,
  length_log = log(___),
  width_sqrt = sqrt(___),
  front_m    = ___ / 1000)
# Visualisation des premières lignes du tableau 
head(___)

#### Attention : solution dans le 'hint' suivant! ####
```

```{r mutate_h3-solution}
## Solution ##
crabs <- smutate(crabs,
  length_log = log(length),
  width_sqrt = sqrt(width),
  front_m    = front / 1000)
# Visualisation des premières lignes du tableau 
head(crabs)
```

```{r mutate_h3-check}
grade_code("Vous savez maintenant comment calculer de nouvelles variables avec la fonction `smutate()`.")
```

### Filtrer et sélectionner des données

Reprenons le jeu de données initial sur nos crabes (`crabs`).

```{r}
# Importation des données sur nos crabes
(crabs <- read("crabs", package = "MASS", lang = "fr"))
```

Réalisez les opérations suivantes avec les fonctions tidy `filter()` et `select()` sur le tableau `crabs` et assignez votre résultat à `crabs2`:

-   Retirer la variable index (`index`) du jeu de données
-   Garder uniquement les individus mâles du jeu de données dont la longueur de la carapace est supérieure ou égale à 25 mm (variables `sex` et `length`)
-   Enregistrez le résultat dans `crabs2`
-   Affichez ensuite les premières lignes du tableau `crabs2`

Employez le chaînage des instructions dans un pipeline pour résoudre cette exercice. Vous devez obtenir le tableau ci-dessous :

```{r}
crabs %>.%
  select(., -index) %>.%
  filter(., sex == "M" & length >= 25) %->%
  crabs2
# Visualisation des six premières lignes du tableau 
head(crabs2)
```

```{r pipe1_h3, exercise=TRUE}
crabs ___
  ___(___, ___) ___
  ___(___, ___ & ___) ___
  ___
___(___)
```

```{r pipe1_h3-hint-1}
crabs %>.%
  select(___, ___) ___
  filter(___, ___ & ___) ___
  ___
head(___)
```

```{r pipe1_h3-hint-2}
crabs %>.%
  select(., - ___) %>.%
  filter(___, sex == ___ & length >= ___) ___
  ___
head(___)

#### Attention : solution dans le 'hint' suivant! ####
```

```{r pipe1_h3-solution}
## Solution ##
crabs %>.%
  select(., -index) %>.%
  filter(., sex == "M" & length >= 25) %->%
  crabs2
head(crabs2)
```

```{r pipe1_h3-check}
grade_code("La sélection de vos variables avec `select()` et de vos observations avec `filter()` (fonctions tidy) nécessite de collecter le résultat soit avec collect_dtx(), soit en utilisant l'assignation alternative %<-%  ou %->% . En général dans un pipeline, finnissez toujours en assignant avec %->%, quelles que soient les fonctions utilisées.")
```

Afin de comparer les fonctions speedy et tidy, réalisez le même exercice en utilisant des fonctions "speedy".

```{r pipe1s_h2, exercise=TRUE}
crabs ___
  ___(___, ___) ___
  ___(___, ___ & ___) %->%
  crabs2
head(crabs2)
```

```{r pipe1s_h2-hint-1}
crabs %>.%
  sselect(___, ___) ___
  ___(___, ___ & ___) %->%
  crabs2
head(crabs2)

#### Attention : solution dans le 'hint' suivant! ####
```

```{r pipe1s_h2-solution}
## Solution ##
crabs %>.%
  sselect(., -index) %>.%
  sfilter(., sex == "M" & length >= 25) %->%
  crabs2
head(crabs2)
```

```{r pipe1s_h2-check}
grade_code("Vous voyez que les fonctions `select()` et `sselect()`, ainsi que `filter()` et `sfilter()` sont quasi-interchageables. Les résultats ne sont cependant pas toujours similaires et vous devez toujours bien vous rappeler de collecter les résultats avec les fonctions tidy (`collect_dtx()`, `%<-%` ou `%->%`).")
```

### Résumer des données

Réalisez les opérations suivantes sur `crabs` :

-   Sélectionnez les individus dont la longueur (`length`) est strictement supérieur à 25 mm
-   Résumez le jeu de données par le sexe (`sex`) et par la variété (`species`) de ce crabe dans cet ordre
    -   Calculez la moyenne de la largeur des carapaces (`width`) par groupe
    -   Dénombrez les individus par groupe (y compris les valeurs manquantes)
    -   Dénombrez les observations par groupe (à l'exclusion des valeurs manquantes)
-   Assignez le résultat à `crabs2`
-   Formatez votre tableau `crabs2` avec la fonction `knitr::kable()`

Employez des fonction speedy et fstat uniquement et le chaînage des opérations dans un pipeline pour résoudre cette exercice. Vous devez obtenir le tableau ci-dessous :

```{r}
crabs %>.%
  sfilter(., length > 25) %>.%
  sgroup_by(., sex, species) |> ssummarise(
    mean         = fmean(width),
    number       = fn(width),
    observations = fnobs(width)) %->%
  crabs2
knitr::kable(crabs2)
```

```{r pipe2_h3, exercise=TRUE}
crabs ___
  ___(___, ___) ___
  ___(___, ___, ___) ___ ___
    mean         = ___(___),
    number       = ___(___),
    observations = ___(___)) ___
  ___
# Tableau formaté avec knitr::kable()
___(___)
```

```{r pipe2_h3-hint-1}
crabs %>.%
  sfilter(___, ___) ___
  sgroup_by(___, ___, ___) ___ ssummarise(
    mean         = ___(___),
    number       = ___(___),
    observations = ___(___)) ___
  ___
# Tableau formaté avec knitr::kable()
knitr::kable(___)
```

```{r pipe2_h3-hint-2}
crabs %>.%
  sfilter(., length > ___) %>.%
  sgroup_by(., ___, ___) |> ssummarise(
    mean         = fmean(___),
    number       = fn(___),
    observations = fnobs(___)) ___
  ___
# Tableau formaté avec knitr::kable()  
knitr::kable(___)

#### Attention : solution dans le 'hint' suivant! ####
```

```{r pipe2_h3-solution}
## Solution ##
crabs %>.%
  sfilter(., length > 25) %>.%
  sgroup_by(., sex, species) |> ssummarise(
    mean         = fmean(width),
    number       = fn(width),
    observations = fnobs(width)) %->%
  crabs2
# Tableau formaté avec knitr::kable()
knitr::kable(crabs2)
```

```{r pipe2_h3-check}
grade_code("Vous avez maintenant compris comment résumer vos données avec `(s)group_by()` et `(s)summarise()` et formater vos sorties avec `knitr::kable()`. Utilisez toujours l'assignation alternative `%->%` en fin de pipeline, c'est plus prudent.")
```

Réalisez à présent un exercice similaire avec les fonctions speedy :

-   Sélectionnez les individus dont la longueur (`length`) est strictement *inférieur ou égale* à 25 mm
-   Résumez le jeu de données par le sexe (`sex`) et par la variété (`species`) de crabe
    -   Calculez la médiane de la largeur des carapaces (`width`) par groupe avec la fonction `fmedian()`
    -   Dénombrez les individus par groupe avec la fonction `fn()`
-   Assignez le résultat à `crabs2`. Utilisez l'assignation adéquate.
-   Formatez votre tableau `crabs2` avec la fonction `knitr::kable()`

Employez le chaînage des opérations au sein d'un pipeline pour résoudre cette exercice. Vous devez obtenir le tableau ci-dessous :

```{r}
crabs %>.%
  sfilter(., length <= 25) %>.%
  sgroup_by(., sex, species) |> ssummarise(
    mean   = fmedian(width),
    number = fn(width)) ->
  crabs2
# Tableau formaté avec knitr::kable()
knitr::kable(crabs2)
```

```{r pipe3_h3, exercise=TRUE}
crabs ___
  ___(___, ___) ___
  ___(___, ___, ___) ___ ___
    median   = ___(___),
    number   = ___(___)) ___
  ___
# Tableau formaté avec knitr::kable()
___(___)
```

```{r pipe3_h3-hint-1}
crabs %>.%
  sfilter(___, ___) ___
  sgroup_by(___, ___, ___) ___ ssummarise(
    median   = ___(___),
    number   = ___(___)) ___
  ___
# Tableau formaté avec knitr::kable()
knitr::kable(___)
```

```{r pipe3_h3-hint-2}
crabs %>.%
  sfilter(., length <= ___) %>.%
  sgroup_by(., ___, ___) |> ssummarise(
    median   = mean(___),
    number   = fn(___)) ___
  ___
# Tableau formaté avec knitr::kable()  
knitr::kable(___)

#### Attention : solution dans le 'hint' suivant! ####
```

```{r pipe3_h3-solution}
## Solution ##
crabs %>.%
  sfilter(., length <= 25) %>.%
  sgroup_by(., sex, species) |> ssummarise(
    median   = fmedian(width),
    number   = fn(width)) %->%
  crabs2
# Tableau formaté avec knitr::kable()
knitr::kable(crabs2)
```

```{r pipe3_h3-check}
grade_code("Vous savez maintenant résumer vos données avec `sgroup_by()` et `ssummarise()`. Vous avez bien assimilé la différence entre les fonctions speedy et tidy.")
```

## Conclusion

Bravo ! Vous venez de terminer votre séance d'exercices relative à la manipulation des données.

Vous maîtriser maintenant :

-   les notions relatives aux remaniement des données avec les fonctions `(s)select()`, `(s)filter()`, `(s)mutate()`, `(s)group_by()`, `(s)summarise()`
-   le chaînages des instructions dans un pipeline
-   l'utilisation judicieuse de `%>.%` pour indiquer que l'on passe à l'opération suivante
-   l'utilisation de `|>` pour organiser le code plus complexe sur un même niveau (typiquement un `(s)group_by()` suivi d'un `(s)summarise()`)
-   l'assignation alternative `%->%` en fin de pipeline tidy pour collecter les résultats dans un tableau

```{r comm_noscore, echo=FALSE}
question_text(
  "Laissez-nous vos impressions sur ce learnr",
  answer("", TRUE, message = "Pas de commentaires... C'est bien aussi."),
  incorrect = "Vos commentaires sont enregistrés.",
  placeholder = "Entrez vos commentaires ici...",
  allow_retry = TRUE
)
```
