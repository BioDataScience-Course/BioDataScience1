---
title: "Remaniement de données"
author: "Guyliann Engels & Philippe Grosjean"
description: "**SDD I Module 4** Remanier des données dans R."
tutorial:
  id: "A04La_wrangling"
  version: 3.0.0/5
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
    fig_caption: yes
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
BioDataScience1::learnr_setup()
SciViews::R(lang = "fr")
# Required for RSConnect
# SciViews::R
library(rlang)
library(data.table)
library(ggplot2)
library(tibble)
library(tidyr)
library(dplyr)
library(dtplyr)
library(broom)
library(forcats)
library(collapse)
library(fs)
library(data.trame)
library(svFast)
library(svTidy)
library(svMisc)
library(svBase)
library(svFlow)
library(data.io)
library(chart)
library(tabularise)
library(SciViews)
# ... more
library(readxl)
library(testthat)
library(equatags)
library(BioDataScience)


# Dataset
crabs <- read("crabs", package = "MASS")
```

```{r, echo=FALSE}
BioDataScience1::learnr_banner()
```

```{r, context="server"}
if (Sys.info()["user"] == "rstudio-connect") {
  options(learnr_user_id = session$user)
  assignInNamespace("default_user_id", function() {
    getOption("learnr_user_id", unname(Sys.info()["user"]))
  }, ns = "learnr")
}
BioDataScience1::learnr_server(input, output, session)
```

------------------------------------------------------------------------

## Objectifs

Le cours de Science des données I : visualisation se divise en deux parties. La première partie traite principalement de la réalisation de graphiques et la seconde du remaniement des données. Ce tutoriel doit vous permettre de :

-   Vérifier l'acquisition des notions relatives au remaniement des données avec les fonctions `select_()`/`select()`, `filter_()`/`filter()`, `mutate_()`/`mutate()`, `group_by_()`/`group_by()`, `summarise_()`/`summarise()`
-   Vérifier l'acquisition des compétences relatives au chaînage des instructions

## Les fonctions svTidy/Tidyverse

L'instruction `SciViews::R` ou `SciViews::R()` qui est équivalente, est employée pour charger une série cohérente de packages R. Nous l'utilisons en début de script R ou dans le premier chunk d'un document Quarto ou R Markdown.

```{r, echo=TRUE, eval=FALSE}
SciViews::R()
```

Vous employez des tableaux de données depuis le premier module de ce cours pour réaliser des graphiques. Vous allez à présent apprendre à les manipuler. Il existe dans R plusieurs types d'objets pour contenir des jeux de données, dont **data.frame**, tibble (objet **tbl_df**) ou **data.table**. Par défaut dans `SciViews::R`, vous travaillez avec des **data.trame**s. La vitesse de traitements et la gestion en mémoire des objets **data.trame** en font le choix idéal pour traiter des gros jeux de données. Actuellement, vous n'avez pas encore traité de gros jeux de données mais cela va venir plus vite que vous ne l'imaginez.

Le remaniement de données est tout un art que vous devez maîtriser. Vous devez être capable de sélectionner des colonnes, de filtrer des lignes, de trier un tableau, de résumer vos observations...

Parmi les fonctions de remaniement de tableaux, nous avons les fonctions svTidy qui visent à accélérer le traitement dans R. Ces fonctions sont compatibles avec les objets **data.trame**. Elles sont suffixées avec un "_" pour les reconnaître facilement.

Un second ensemble est constitué des fonctions [Tidyverse](https://www.tidyverse.org), et portant le même nom que leurs homologues svTidy, mais non suffixées d'un "_". Elles sont couramment utilisées dans R, mais, dans la plupart des cas, plus lentes que les fonctions svTidy correspondantes, et elles n'utilisent pas l'interface formule qsui vous est familière avec, entre autres, `chart()`.

Nous retrouvons donc des paires de fonctions svTidy/Tidyverse qui réalisent des traitements très similaires et ont une syntaxe relativement proche. Elles permettent de :

-   sélectionner des colonnes d'un jeu de données avec `select_()`/`select()`
-   filtrer des lignes dans un jeu de données avec `filter_()`/`filter()`
-   calculer de nouvelles variables dans un jeu de données avec `mutate_()`/`mutate()`
-   indiquer les variables de regroupement à utiliser dans un tableau avec `group_by_()`/`group_by()`
-   résumer les variables d'un jeu de données avec `summarise_()`/`summarise()`

*Nous vous conseillons d'employer préférentiellement les fonctions svTidy.* Cependant, dans ce tutoriel nous utiliserons alternativement les deux pour se familiariser avec les deux syntaxes.

## Deux variétés de crabes

Le tableau de données que vous allez employer porte sur deux variétés de crabes.

```{r, echo=TRUE}
SciViews::R(lang = "fr")
# Importation des données crabs
(crabs <- read("crabs", package = "MASS"))
```

Ce tableau contient `r nrow(crabs)` observations et `r ncol(crabs)` variables. Les carapaces d'individus mâles et femelles de deux variétés de crabes ont été mesurées sous toutes les coutures.

### Calculer de nouvelles variables

Calculez sur le tableau `crabs` à l'aide de la fonction svTidy `mutate_()` :

-   le logarithme (`log()`) de la longueur de la carapace (`length`) des crabes et nommez cette nouvelle variables `log_length`
-   la racine carrée (`sqrt()`) de la largueur de la carapace (`width`) et nommez cette nouvelle variable `sqrt_width`
-   Divisez la variable lobe frontal (`front`) par 1000 et nommez cette nouvelle variable `front_m`

Affichez ensuite les premières lignes du tableau (`head()`). Par défaut, les six premières lignes sont affichées. Vous devez obtenir le tableau ci-dessous :

```{r}
crabs <- mutate_(crabs,
  log_length = ~log(length),
  sqrt_width = ~sqrt(width),
  front_m    = ~front / 1000)
# Visualisation des premières lignes du tableau
head(crabs)
```

```{r mutate_h3, exercise=TRUE}
___ <- ___(___,
  ___ = ___,
  ___ = ___,
  ___ = ___)
# Visualisation des premières lignes du tableau
___(___)
```

```{r mutate_h3-hint-1}
DF <- mutate_(___,
  log_length = ___,
  sqrt_width = ___,
  front_m    = ___)
# Visualisation des premières lignes du tableau
head(___)
```

```{r mutate_h3-hint-2}
crabs <- mutate_(crabs,
  log_length = ~log(___),
  sqrt_width = ~sqrt(___),
  front_m    = ___ / 1000)
# Visualisation des premières lignes du tableau
head(___)

#### Attention : solution dans le 'hint' suivant! ####
```

```{r mutate_h3-solution}
## Solution ##
crabs <- mutate_(crabs,
  log_length = ~log(length),
  sqrt_width = ~sqrt(width),
  front_m    = ~front / 1000)
# Visualisation des premières lignes du tableau
head(crabs)
```

```{r mutate_h3-check}
grade_code("Vous savez maintenant comment calculer de nouvelles variables avec la fonction svTidy `mutate_()` qui utilise des formules commençant par `~` pour effectuer les transformations désirées.")
```

### Filtrer et sélectionner des données

Reprenons le jeu de données initial `crabs`.

```{r}
# Importation des données
(crabs <- read("crabs", package = "MASS", lang = "fr"))
```

Réalisez les opérations suivantes avec les fonctions **Tidyverse** `filter()` et `select()` et assignez votre résultat à `crabs2` :

-   Retirer la variable index (`index`) du jeu de données
-   Garder uniquement les individus mâles (`"M"`) du jeu de données dont la longueur de la carapace est supérieure ou égale à 25 mm (variables `sex` et `length` respectivement)
-   Enregistrez le résultat dans `crabs2`
-   Affichez ensuite les premières lignes du tableau `crabs2`

Employez le chaînage des instructions avec `%>.%` dans un pipeline pour résoudre cette exercice. Vous devez obtenir le tableau ci-dessous :

```{r}
crabs %>.%
  select(., -index) %>.%
  filter(., sex == "M" & length >= 25) ->
  crabs2
# Visualisation des six premières lignes du tableau
head(crabs2)
```

```{r pipe1_h3, exercise=TRUE}
crabs ___
  ___(___, ___) ___
  ___(___, ___ & ___) ___
  ___
___(___)
```

```{r pipe1_h3-hint-1}
crabs %>.%
  select(___, ___) ___
  filter(___, ___ & ___) ___
  ___
head(___)
```

```{r pipe1_h3-hint-2}
crabs %>.%
  select(., - ___) %>.%
  filter(___, sex == ___ & length >= ___) ___
  ___
head(___)

#### Attention : solution dans le 'hint' suivant! ####
```

```{r pipe1_h3-solution}
## Solution ##
crabs %>.%
  select(., -index) %>.%
  filter(., sex == "M" & length >= 25) ->
  crabs2
head(crabs2)
```

```{r pipe1_h3-check}
grade_code("La sélection de vos variables avec `select()` et de vos observations avec `filter()` (fonctions tidyverse) réalisent cette transformation. En général dans un pipeline, finissez toujours en assignant avec `->` pour que l'assignation apparaisse à la fin dans la logique de succession des opérations et mettez en évidence le nom auquel vous assignez en le plaçant sur une nouvelle ligne.")
```

Afin de comparer les fonctions svTidy et tidyverse, réalisez le même exercice en utilisant cette fois-ci des fonctions svTidy.

```{r pipe1s_h2, exercise=TRUE}
crabs ___
  ___(___, ___) ___
  ___(___, ___ & ___) ->
  crabs2
head(crabs2)
```

```{r pipe1s_h2-hint-1}
crabs %>.%
  select_(___, ___) ___
  ___(___, ___ & ___) ->
  crabs2
head(crabs2)

#### Attention : solution dans le 'hint' suivant! ####
```

```{r pipe1s_h2-solution}
## Solution ##
crabs %>.%
  select_(., ~-index) %>.%
  filter_(., ~sex == "M" & length >= 25) ->
  crabs2
head(crabs2)
```

```{r pipe1s_h2-check}
grade_code("Vous voyez que les fonctions `select()` et `select_()`, ainsi que `filter()` et `filter_()` apparaissent souvent interchageables, à condition de bien penser à utiliser des formules avec les fonctions svTidy (ajouter un `~` au début des expressions. Les résultats ne sont cependant pas toujours similaires et vous devez restez attentif à cela dans votre code, par exemple, si vous traduisez un exemple tidyverse trouvé sur le Web en version svTidy.")
```

### Résumer des données

Réalisez les opérations suivantes sur `crabs` :

-   Sélectionnez les individus dont la longueur (`length`) est strictement supérieure à 25 mm
-   Résumez le jeu de données par le sexe (`sex`) et par la variété (`species`) de ce crabe dans cet ordre
    -   Calculez la moyenne de la largeur des carapaces (`width`) par groupe
    -   Dénombrez les individus par groupe (y compris les valeurs manquantes)
    -   Dénombrez les observations par groupe (à l'exclusion des valeurs manquantes)
-   Assignez le résultat à `crabs2`
-   Formatez votre tableau `crabs2` avec `knitr::kable()`

Employez des fonction svTidy et fstat uniquement (pour rappel, les functions fast commencent par un `f`, par exemple, `fmean()` est l'équivalent fast de la fonction R de base `mean()`) et le chaînage des opérations avec `%>.%` dans un pipeline pour résoudre cette exercice. Vous devez obtenir le tableau ci-dessous :

```{r}
crabs %>.%
  filter_(., ~length > 25) %>.%
  group_by_(., ~sex, ~species) %>.%
  summarise_(.,
    mean = ~fmean(width),
    ntot = ~fn(width),
    nobs = ~fnobs(width)) ->
  crabs2
knitr::kable(crabs2)
```

```{r pipe2_h3, exercise=TRUE}
crabs ___
  ___(___, ___) ___
  ___(___, ___, ___) ___
  ___(___,
    mean = ___(___),
    ntot = ___(___),
    nobs = ___(___)) ___
  ___
# Tableau formaté avec knitr::kable()
___(___)
```

```{r pipe2_h3-hint-1}
crabs %>.%
  filter_(___, ___) ___
  group_by_(___, ___, ___) ___
  summarise_(___,
    mean = ___(___),
    ntot = ___(___),
    nobs = ___(___)) ___
  ___
# Tableau formaté avec knitr::kable()
knitr::kable(___)
```

```{r pipe2_h3-hint-2}
crabs %>.%
  filter_(., ~length > ___) %>.%
  group_by_(., ___, ___) %>.%
  summarise_(.,
    mean = ~fmean(___),
    ntot = ~fn(___),
    nobs = ~fnobs(___)) ___
  ___
# Tableau formaté avec knitr::kable()
knitr::kable(___)

#### Attention : solution dans le 'hint' suivant! ####
```

```{r pipe2_h3-solution}
## Solution ##
crabs %>.%
  filter_(., ~length > 25) %>.%
  group_by_(., ~sex, ~species) %>.%
  summarise_(.,
    mean = ~fmean(width),
    ntot = ~fn(width),
    nobs = ~fnobs(width)) ->
  crabs2
# Tableau formaté avec knitr::kable()
knitr::kable(crabs2)
```

```{r pipe2_h3-check}
grade_code("Vous avez maintenant compris comment résumer vos données avec `group_by_()` et `summarise_()` et formater vos sorties avec `knitr::kable()`.")
```

Réalisez à présent un exercice similaire, toujour avec les fonctions svTidy :

-   Sélectionnez les individus dont la longueur (`length`) est strictement *inférieur ou égale* à 25 mm
-   Résumez le jeu de données par le sexe (`sex`) et par la variété (`species`) de crabe
    -   Calculez la médiane de la largeur des carapaces (`width`) par groupe
    -   Dénombrez les individus (nombre total, valeurs manquantes comprises)
-   Assignez le résultat à `crabs2`
-   Formatez votre tableau `crabs2` avec la fonction `knitr::kable()`

Employez le chaînage des opérations `%>.%` au sein d'un pipeline pour résoudre cette exercice. Vous devez obtenir le tableau ci-dessous :

```{r}
crabs %>.%
  filter_(., ~length <= 25) %>.%
  group_by_(., ~sex, ~species) %>.%
  summarise_(.,
    median = ~fmedian(width),
    ntot   = ~fn(width)) ->
  crabs2
# Tableau formaté avec knitr::kable()
knitr::kable(crabs2)
```

```{r pipe3_h3, exercise=TRUE}
crabs ___
  ___(___, ___) ___
  ___(___, ___, ___) ___
  ___(___,
    median = ___(___),
    ntot   = ___(___)) ___
  ___
# Tableau formaté avec knitr::kable()
___(___)
```

```{r pipe3_h3-hint-1}
crabs %>.%
  filter_(___, ___) ___
  group_by_(___, ___, ___) ___
  summarise_(___,
    median = ___(___),
    ntot.  = ___(___)) ___
  ___
# Tableau formaté avec knitr::kable()
knitr::kable(___)
```

```{r pipe3_h3-hint-2}
crabs %>.%
  filter_(., ~length <= ___) %>.%
  group_by_(., ___, ___) %>.%
  summarise_(.,
    median = ~fmedian(___),
    ntot   = ~fn(___)) ___
  ___
# Tableau formaté avec knitr::kable()
knitr::kable(___)

#### Attention : solution dans le 'hint' suivant! ####
```

```{r pipe3_h3-solution}
## Solution ##
crabs %>.%
  filter_(., ~length <= 25) %>.%
  group_by_(., ~sex, ~species) %>.%
  summarise_(.,
    median = ~fmedian(width),
    ntot   = ~fn(width)) ->
  crabs2
# Tableau formaté avec knitr::kable()
knitr::kable(crabs2)
```

```{r pipe3_h3-check}
grade_code("Vous savez maintenant résumer vos données avec `group_by_()` et `summarise_()`.")
```

## Conclusion

Bravo ! Vous venez de terminer votre séance d'exercices relative à la manipulation des données.

Vous avez maintenant un aperçu de :

-   notions relatives aux remaniement des données avec les fonctions `select_()`/`select()`, `filter_()`/`filter()`, `mutate_()`/`mutate()`, `group_by_()`/`group_by()`, `summarise_()`/`summarise()`
-   chaînages des instructions dans un pipeline avec `%>.%`

```{r comm_noscore, echo=FALSE}
question_text(
  "Laissez-nous vos impressions sur ce learnr",
  answer("", TRUE, message = "Pas de commentaires... C'est bien aussi."),
  incorrect = "Vos commentaires sont enregistrés.",
  placeholder = "Entrez vos commentaires ici...",
  allow_retry = TRUE
)
```

```{css, echo=FALSE}
@media print {
  .topics {
    width: 100% !important;
    padding: 0 0.5em 0 !important;
  }
  .topicsContainer, .topicsContainer *, .learnrBanner, .learnrBanner *, .topicActions, .topicActions * {
    display: none !important;
  }
}
```
