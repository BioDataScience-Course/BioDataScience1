---
title: "Recombinaison de tableaux"
author: "Guyliann Engels & Philippe Grosjean"
description: "**SDD I Module 5** Recombiner des tableaux de long en large et vice versa."
tutorial:
  id: "A05La_recombination"
  version: 3.0.0/5
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
BioDataScience1::learnr_setup()
SciViews::R(lang = "fr")
# Required for RSConnect
# SciViews::R
library(rlang)
library(data.table)
library(ggplot2)
library(tibble)
library(tidyr)
library(dplyr)
library(dtplyr)
library(broom)
library(forcats)
library(collapse)
library(fs)
library(data.trame)
library(svFast)
library(svTidy)
library(svMisc)
library(svBase)
library(svFlow)
library(data.io)
library(chart)
library(tabularise)
library(SciViews)
# ... more
library(readxl)
library(testthat)
library(equatags)
library(BioDataScience)
```

```{r, echo=FALSE}
BioDataScience1::learnr_banner()
```

```{r, context="server"}
if (Sys.info()["user"] == "rstudio-connect") {
  options(learnr_user_id = session$user)
  assignInNamespace("default_user_id", function() {
    getOption("learnr_user_id", unname(Sys.info()["user"]))
  }, ns = "learnr")
}
BioDataScience1::learnr_server(input, output, session)
```

## Objectifs

-   Recombiner des tableaux larges en longs

-   Recombiner des tableaux longs en larges

-   Séparer et unifier des colonnes dans un tableau de données

## De large vers long

Le format long d'un tableau de données correspond à un encodage en un minimum de colonnes, les données étant réparties sur un plus grand nombre de lignes en comparaison du format large qui regroupe les données dans plusieurs colonnes successives. Il est assez courant de devoir transformer un tableau large vers un tableau long. Cela permet souvent d'obtenir un tableau cas par variables correct. La fonction utile pour cela est `pivot_longer()` en version Tidyverse, ou `pivot_longer_()` en version svTidy.

```{r, eval=FALSE, echo=TRUE}
DF1 <- pivot_longer_(DF, cols = SELECTION, names_to = NEWVAR1, values_to = NEWVAR2)
```

La fonction `pivot_longer()` ou `pivot_longer_()` a les arguments principaux suivants :

-   `cols =` : les variables qui doivent être pivotées
-   `names_to =` : le nom de la nouvelle variable qui reprend le nom des colonnes pivotées
-   `values_to =` : le nom de la nouvelle variable qui reprend les valeurs des colonnes pivotées

```{r wide-init}
time <- 1989:1995
tree <- rep(c("arbre_1", "arbre_2"), each = length(time))
size <- c((time - 1990 + 12) * 2, (time - 1990 + 15) * 2.5)

long <- dtx(
  year    = c(time, time),
  tree    = tree,
  circumf = size
)

wide <- pivot_wider_(long, names_from = 'year', values_from = 'circumf')
long1 <- pivot_longer_(wide, cols = ~'1989':'1995', names_to = 'year',
  values_to = 'circumf')
```

Voici un jeu de données nommé `wide` :

```{r}
knitr::kable(wide)
```

Modifiez ce tableau `wide` afin d'obtenir le tableau suivant que vous nommerez `long` :

```{r,}
knitr::kable(long1)
```

### Première variante de l'argument cols

Complétez le code pour obtenir le tableau `long` avec une fonction tidyverse.

```{r wide-prep}
time <- 1989:1995
tree <- rep(c("arbre_1", "arbre_2"), each = length(time))
size <- c((time - 1990 + 12)*2, (time - 1990 + 15)*2.5)

long <- dtx(
  year    = c(time, time),
  tree    = tree,
  circumf = size
)

wide <- pivot_wider_(long, names_from = 'year', values_from = 'circumf')
```

```{r wide1_h3, exercise = TRUE, exercise.setup = "wide-prep"}
___ <- ___(___, cols = "___":"___", names_to = "___",
  values_to = "___")
head(___)
```

```{r wide1_h3-hint-1}
long <- pivot_longer(wide, cols = "___":"___", names_to = "___",
  values_to = "___")
head(long)
```

```{r wide1_h3-hint-2}
long <- pivot_longer(wide, cols = "1989":"1995", names_to = "___",
  values_to = "___")
head(long)

#### Attention : solution dans le 'hint' suivant! ####
```

```{r wide1_h3-solution}
## Solution ##
long <- pivot_longer(wide, cols = "1989":"1995", names_to = "year",
  values_to = "circumf")
head(long)
```

```{r wide1_h3-check}
grade_code("Vous venez de réaliser votre premier pivot de tableau.")
```

### Seconde variante de l'argument cols =

L'argument `cols =` de la fonction de pivot accepte plusieurs écritures pour spécifier les colonnes d'intérêts. Retirez la colonne qui ne doit pas subir le pivot dans la variante suivante pour à nouveau obtenir votre tableau `long`. Utilisez cette fois-ci la fonction svTidy.

```{r wide2_h2, exercise = TRUE, exercise.setup = "wide-prep"}
___ <- ___(___, cols = ___, names_to = "___",
  values_to = "___")
head(___)
```

```{r wide2_h2-hint-1}
long <- pivot_longer_(wide, cols = ~!___, names_to = "year",
  values_to = "circumf")
head(___)

#### Attention : solution dans le 'hint' suivant! ####
```

```{r wide2_h2-solution}
## Solution ##
long <- pivot_longer_(wide, cols = ~!tree, names_to = "year",
  values_to = "circumf")
head(long)
```

```{r wide2_h2-check}
grade_code("Cette variante est parfois plus pratique, surtout avec des grands tableaux. Elle fonctionne aussi bien avec les fonctions tidyverse que svTidy, à condition pour ces dernières de ne pas oublier de transformer l'expression en formule en ajoutant un `~` devant.")
```

### Troisième variante de l'argument cols =

Pour l'argument `cols =` vous pouvez aussi utiliser `starts_with()` pour sélectionner les colonnes dont le nom commence par une chaîne de caractères donnée. Créez à nouveau un tableau nommé `long` à partir du tableau `wide`. Utilisez à nouveau la fonction tidyverse ici.

```{r wide3_h2, exercise = TRUE, exercise.setup = "wide-prep"}
___ <- ___(., cols = ___("___"), names_to = "___",
  values_to = "___")
head(___)
```

```{r wide3_h2-hint-1}
long <- pivot_longer(wide, cols = starts_with("___"), names_to = "year",
  values_to = "circumf")
head(long)

#### Attention : solution dans le 'hint' suivant! ####
```

```{r wide3_h2-solution}
## Solution ##
long <- pivot_longer(wide, cols = starts_with("19"), names_to = "year",
  values_to = "circumf")
head(long)
```

```{r wide3_h2-check}
grade_code("La sélection de variables à l'aide de `starts_with()` ou `ends_with()` peut rendre de grands services ici, tout comme dans `select_()`/`select()`, par exemple, elle fonctionne aussi avec les fonctions svTidy, après avoir transformé l'expression en formule.")
```

## De long vers large

Il est plus rare de passer d'un tableau long vers un tableau large. Cela est souvent utilisé lorsque l'on souhaite transformer le jeu de données pour le rendre plus compact (par exemple, pour l'imprimer dans un rapport ou dans une présentation). La fonction utile pour cette transformation est `pivot_wider()` (version tidyverse) ou `pivot_wider_()`(version svTidy).

```{r, eval=FALSE, echo=TRUE}
DF1 <- pivot_wider_(DF, names_from = VAR1, values_from = VAR2)
```

La fonction `pivot_wider()` ou `pivot_wider_()` a pour principaux arguments :

-   `names_from =` : le nom de la variable dont les valeurs vont être employées comme les noms des nouvelles variables.
-   `values_from =` : le nom de la variable dont les valeurs vont être employées comme les valeurs des nouvelles variables.

```{r long-init}
gr_age <- c("Jeune", "Adulte","Senior")
period <- c(1992, 1995, 1998)
popu   <- c(2185103, 6311109, 1525785,
            2196799, 6337067, 1596532,
            2180816, 6332857, 1678591)

demography <- dtx(
  groupe_age = rep(gr_age, times = 3L),
  year       = rep(period, each = 3L),
  population = popu
)

demo <- pivot_wider_(demography, names_from = 'year', values_from = 'population')
```

Voici un petit jeu de données au format long nommé `demography` :

```{r}
knitr::kable(demography)
```

Modifiez ce tableau `demography` en un tableau large que vous nommerez `demo` :

```{r}
knitr::kable(demo)
```

```{r long-prep}
gr_age <- c("Jeune", "Adulte","Senior")
period <- c(1992, 1995, 1998)
popu   <- c(2185103, 6311109, 1525785,
            2196799, 6337067, 1596532,
            2180816, 6332857, 1678591)

demography <- dtx(
  groupe_age = rep(gr_age, times = 3L),
  year       = rep(period, each = 3L),
  population = popu
)
```

Complétez l'instruction ci-dessous en utilisant une fonction tidyverse.

```{r long_h2, exercise=TRUE, exercise.setup="long-prep"}
___ <- ___(___, names_from = ___, values_from = ___)
head(___)
```

```{r long_h2-hint-1}
demo <- pivot_wider(demography, names_from = ___, values_from = ___)
head(demo)

#### Attention : solution dans le 'hint' suivant! ####
```

```{r long_h2-solution}
## Solution ##
demo <- pivot_wider(demography, names_from = "year", values_from = "population")
head(demo)
```

```{r long_h2-check}
grade_code("Vous venez de réaliser un tableau large en partant d'un tableau long. Comme vous pouvez le voir, la syntaxe est très similaire entre `pivot_wider()` et `pivot_longer()` (ou leurs équivalents svTidy). Elles se complètent parfaitement.")
```

## Diviser des colonnes dans un tableau

La fonction à utiliser pour créer plusieurs variables en séparant les éléments qui se trouvent dans une seule colonne est `separate()` en tidyverse ou `separate_()` en svTidy. La fonction `unite()` ou `unite_()` est complémentaire de `separate()`/`separate_()` et crée une seule variable à partir de plusieurs.

```{r, eval=FALSE, echo=TRUE}
DF1 <- separate_(DF, col = VARNAME, into = c("VAR1", "VAR2"),
  sep = "[^[:alnum:]]+")
```

La fonction `separate()` ou `separate_()` a les principaux arguments suivants :

-   `col =` : le nom de la variable à scinder
-   `into =` : le nom des nouvelles variables
-   `sep =` : le séparateur qui permet de scinder la variable sélectionnée en `col =`

```{r separate_init}
bacteria <- dtx(
  batch = paste(
    rep(c("ind1", "ind2", "ind3"), each = 3L),
    rep(c("2019-04-25", "2019-04-26", "2019-04-27"), times = 3L),
    sep = "_"),
  value = c((11:13)^3, (11:13)^4, (11:13)^5)
)

bact <- separate_(bacteria, col = 'batch', into = c('rep', 'date'), sep = "_" )
```

Voici un jeu de données nommé `bacteria` dont la première colonne combine deux informations (le lot et la date) :

```{r}
knitr::kable(bacteria)
```

Modifiez ce tableau `bacteria` en un tableau à trois colonnes que vous nommerez `bact` en utilisant une fonction svTidy :

```{r}
knitr::kable(bact)
```

```{r separate_prep}
bacteria <- dtx(
  batch = paste(
    rep(c("ind1", "ind2", "ind3"), each = 3L),
    rep(c("2019-04-25", "2019-04-26", "2019-04-27"), times = 3L),
    sep = "_"),
  value = c((11:13)^3, (11:13)^4, (11:13)^5)
)
```

```{r separate_h2, exercise = TRUE, exercise.setup = "separate_prep"}
___ <- ___(___, col = ___,
  into = c("___", "___"), sep = "___")
head(___)
```

```{r separate_h2-hint-1}
bact <- separate_(bacteria, col = "batch",
  into = c("___", "___"), sep = "___")
head(bact)

#### Attention : solution dans le 'hint' suivant! ####
```

```{r separate_h2-solution}
## Solution ##
bact <- separate_(bacteria, col = "batch",
  into = c("rep", "date"), sep = "_" )
head(bact)
```

```{r separate_h2-check}
grade_code("Vous venez de scinder une colonne de votre tableau avec `separate_()`. Vous pouvez également utiliser `separate()` en mode tidyverse.")
```

## Conclusion

Félicitation ! Vous êtes maintenant capables de convertir des tableaux de long en large et inversement et de scinder des variables.

```{r comm_noscore, echo=FALSE}
question_text(
  "Laissez-nous vos impressions sur ce learnr",
  answer("", TRUE, message = "Pas de commentaires... C'est bien aussi."),
  incorrect = "Vos commentaires sont enregistrés.",
  placeholder = "Entrez vos commentaires ici...",
  allow_retry = TRUE
)
```

```{css, echo=FALSE}
@media print {
  .topics {
    width: 100% !important;
    padding: 0 0.5em 0 !important;
  }
  .topicsContainer, .topicsContainer *, .learnrBanner, .learnrBanner *, .topicActions, .topicActions * {
    display: none !important;
  }
}
```
