---
title: "Remaniement de données"
author: "Guyliann Engels & Philippe Grosjean"
description: "**SDD I Module 5** Importer et remanier des données dans R."
tutorial:
  id: "A05La_wrangling"
  version: 2.2.0/5
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
    fig_caption: yes
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
BioDataScience1::learnr_setup()
SciViews::R(lang = "fr")
library(BioDataScience)

# Dataset
crabs <- read("crabs", package = "MASS")
```

```{r, echo=FALSE}
BioDataScience1::learnr_banner()
```

```{r, context="server"}
BioDataScience1::learnr_server(input, output, session)
```

------------------------------------------------------------------------

## Objectifs

Le cours de Science des données I : visualisation se divise en deux parties. La première partie traite principalement de la réalisation de graphiques et la seconde du remaniement des données. Ce tutoriel doit vous permettre de :

-   Vérifier l'acquisition des notions relatives aux remaniement des données avec les fonctions `select()`/`sselect()`, `filter()`/`sfilter()`, `mutate()`/`smutate()`, `group_by()`/`sgroup_by()`, `summarise()`/`ssummarise()`
-   Vérifier l'acquisition des compétences relatives au chaînage des instructions

## Les fonctions speedy/tidy

La fonction`SciViews::R()` est employée afin de charger une série cohérente de packages R. Nous l'utilisons en début de script R ou encore dans le premier chunk d'un rapport d'analyse au format R Markdown.

```{r, echo=TRUE, eval=FALSE}
SciViews::R()
```

Vous employez des tableaux de données depuis le premier module de ce cours afin de réaliser des graphiques. Vous allez à présent apprendre à les manipuler ces tableaux. Il existe dans R plusieurs types d'objets pour traiter les tableaux de données (*data frame*) dont **data.frame**, **tibble** ou **data.table**. Dans ce cours, nous avons décidé de travailler avec des objets de type **data.table**. La vitesse de traitements et la gestion en mémoire des objets **data.table** en font le choix idéal dans la gestion de gros jeux de données. Actuellement, vous n'avez pas encore traité des gros jeux de données mais cela va venir plus vite que vous ne l'imaginez.

Le remaniement de données est tout un art que vous devez maîtriser. Vous devez être capable de sélectionner des colonnes, de filtrer des lignes, de trier un tableau, de résumer vos observations,...

Il est possible de réaliser des regroupements de fonctions lié au remaniement dans R. Nous avons les fonctions "speedy" élaborées dans le nouveau package {svBase} sur base de travail réalisé dans un autre package : {collapse} qui vise à accélérer le traitement de telles fonctions dans R. Ces fonctions speedy sont compatibles avec les objets **data.table**. Elles sont préfixées avec un "s" pour les reconnaître facilement.

```{r, echo=TRUE}
list_speedy_functions()
```

Un second ensemble de fonction sont les fonctions tidy associée au [Tidyverse](https://www.tidyverse.org).

```{r, echo=TRUE}
list_tidy_functions()
```

En résumé, on retrouve un équivalent aux fonctions "tidy" principales du package {dplyr} mais sous forme "speedy". Les arguments des fonctions et les résultats renvoyés sont très similaires :

-   sélectionner des colonnes au sein d'un jeu de données avec `select()`/`sselect()`
-   filtrer des lignes dans un jeu de données avec `filter()`/`sfilter()`
-   calculer de nouvelles variables dans un jeu de données avec `mutate()`/`smutate()`
-   indiquer les variables de regroupement à utiliser dans un tableau avec `group_by()`/`sgroup_by()`
-   résumer les variables d'un jeu de données avec `summarise()`/`ssummarise()`

*Nous vous conseillons d'employer préférentiellement les fonctions speedy.* Vous trouverez un exemple d'instruction ci-dessous équivalente.

```{r, echo=TRUE, eval=FALSE}
# Assignation classique avec fonctions "speedy" => version conseillée
crabs1 <- sselect(crabs, species, sex, length) 
# Assignation alternative avec fonctions "tidy"
crabs1 %<-% select(crabs, species, sex, length)
```

Si vous analysez ces instructions, il y a un élément qui doit vous sauter aux yeux. On peut observer une assignation particulière avec les fonctions "tidy" dans `SciViews::R`. Avec les fonctions tidy dans `SciViews::R`, il faut prendre soin de collecter les résultats à la fin si l'on travaille avec des objets de classe **data.table**. C'est le package {dtplyr} qui gère les calculs en interne. Utilisez l'assignation alternative `%<-%` ou `%->%`, ou alors, explicitement `collect_dtx()` pour récupérer un data frame utilisable ensuite avec les fonctions non-tidy.

```{r, echo=TRUE, eval=FALSE}
#  Assignation alternative avec fonctions "tidy"
crabs1 %<-% select(crabs, species, sex, length)
#  Assignation classique avec collect_dtx() (plus lourd) 
crabs1 <- collect_dtx(select(crabs, species, sex , length))
#  Assignation classique avec collect_dtx() et le pipe natif de R (plus lourd)
crabs1 <- select(crabs, species, length) |> collect_dtx()
```

## La biométrie des crabes

Le tableau de données que vous allez employer porte sur la biométrie des crabes.

```{r, echo = TRUE}
SciViews::R(lang = "fr")
# Importation des données sur la biométrie des crabes
(crabs <- read("crabs", package = "MASS"))
```

Ce tableau comprends `r nrow(crabs)` observations et `r ncol(crabs)` variable. On recense des individus mâles et femelles de deux espèces de crabes.

### Calculer de nouvelles variables

Calculez sur le tableau `crabs` à l'aide de la fonction `smutate()` :

-   le logarithme (`log()`) de la longueur de la carapace (`length`) des crabes et nommez cette nouvelle variables **length_log**
-   la racine carrée (`sqrt()`) de la largueur de la carapace (`width`) et nommez cette nouvelle variable **width_sqrt**
-   Divisez la variable lobe frontal (`front`) par 1000 et nommez cette nouvelle variable **front_m**

Affichez ensuite les premières lignes du tableau (`head()`). Par défaut, les 6 premières lignes sont affichées)

Vous devez obtenir le tableau ci-dessous :

```{r}
# smutate
crabs <- smutate(crabs, 
  length_log = log(length),
  width_sqrt = sqrt(width),
  front_m    = front/1000)
# Visualisation des premières lignes du tableau 
head(crabs)
```

```{r mutate_h3, exercise=TRUE}
# smutate
___ <- ___(___,
  ___ = ___,
  ___ = ___,
  ___ = ___)
# Visualisation des premières lignes du tableau 
___(___)
```

```{r mutate_h3-hint-1}
# smutate
DF <- smutate(___,
  length_log = ___,
  width_sqrt = ___,
  front_m    = ___)
# Visualisation des premières lignes du tableau 
head(___)
```

```{r mutate_h3-hint-2}
# smutate
crabs <- smutate(crabs,
  length_log = log(___),
  width_sqrt = sqrt(___),
  front_m    = ___/1000)
# Visualisation des premières lignes du tableau 
head(___)

#### Attention : solution dans le 'hint' suivant! ####
```

```{r mutate_h3-solution}
# smutate
crabs <- smutate(crabs,
  length_log = log(length),
  width_sqrt = sqrt(width),
  front_m    = front/1000)
# Visualisation des premières lignes du tableau 
head(crabs)
```

```{r mutate_h3-check}
grade_code("Vous savez maintenant comment calculer de nouvelles variables avec la fonction `smutate()`.")
```

### Filtrer et sélectionner des données

Réalisez les opérations suivantes avec les fonctions `filter()` et `select()` sur le tableau `crabs` et assignez ce résultat à `crabs2`:

-   Retirer la variable index (`index`) du jeu de données
-   Garder uniquement les individus mâles du jeu de données dont la longueur de la carapace est supérieure ou égale à 25 mm (variables `sex` et `length`)
-   Affichez ensuite les premières lignes du tableau (par défaut, les 6 premières lignes sont affichées). Attention ! Comme la fonction que vous utiliserez est non-tidy, il faut collecter le tableau de résultats avant !

Employez le chaînage des instructions au sein d'un pipeline pour résoudre cette exercice.

Vous devez obtenir le tableau ci-dessous :

```{r}
crabs %>.%
  select(., -index) %>.%
  filter(., sex == "M" & length >= 25) %>.%
  collect_dtx(.) -> 
  crabs2
# Visualisation des  six premières lignes du tableau 
head(crabs2)
```

```{r pipe1_h3, exercise=TRUE}
crabs ___
  ___(___, ___) ___
  ___(___, ___ & ___) ___
  collect_dtx(___) -> 
  crabs2
# Visualisation des  six premières lignes du tableau 
head(crabs2)
```

```{r pipe1_h3-hint-1}
crabs %>.%
  select(___, ___) ___
  filter(___, ___ & ___) ___
  collect_dtx(___) -> 
  crabs2
# Visualisation des  six premières lignes du tableau 
head(crabs2)
```

```{r pipe1_h3-hint-2}
crabs %>.%
  select(., - ___) %>.%
  filter(___, sex == ___ & length >= ___) ___
collect_dtx(___) -> 
  crabs2
# Visualisation des  six premières lignes du tableau 
head(crabs2)
```

```{r pipe1_h3-solution}
crabs %>.%
  select(., -index) %>.%
  filter(., sex == "M" & length >= 25) %>.%
  collect_dtx(.) -> 
  crabs2
# Visualisation des  six premières lignes du tableau 
head(crabs2)
```

```{r pipe1_h3-check}
grade_code("Vous maitrisez maintenant la sélection de vos variables avec `select()` et de vos observations avec `filter()`. Ce sont des fonctions tidy, donc, pensez bien à collecter les résultats à la fin avec `collect_dtx()`, ou en assignant avec `%<-%` ou `%->%` !")
```

Afin de comparer les fonctions "speedy et"tidy", réalisez le même exercice en utilisant les fonctions "speedy".

```{r pipe1s_h2, exercise=TRUE}
crabs ___
  ___(___, ___) ___
  ___(___, ___ & ___) -> 
  crabs2
# Visualisation des  six premières lignes du tableau 
head(crabs2)
```

```{r pipe1s_h2-hint-1}
crabs %>.%
  sselect(___, ___) ___
  ___(___, ___ & ___) -> 
  crabs2
# Visualisation des  six premières lignes du tableau 
head(crabs2)
```

```{r pipe1s_h2-solution}
crabs %>.%
  sselect(., -index) %>.%
  sfilter(., sex == "M" & length >= 25) -> 
  crabs2
# Visualisation des  six premières lignes du tableau 
head(crabs2)
```

```{r pipe1s_h2-check}
grade_code("Vous maitrisez maintenant la sélection de vos variables avec `sselect()` et de vos observations avec `sfilter()`.")
```

### Résumer des données

Réalisez les opérations suivantes sur `crabs` :

-   Sélectionnez les individus dont la longueur (`length`) est strictement supérieur à 25 mm
-   Résumez le jeu de données par le sexe (`sex`) et par la variété (`species`) de *Leptograpsus variegatus*
    -   Calculez la moyenne de la largeur des carapaces (`width`) par groupe
    -   Dénombrez les individus par groupe avec la fonction `n()`
-   Assignez le résultat à `crabs2`. Utilisez l'assignation adéquate.
-   Formatez votre tableau `crabs2` avec la fonction `knitr::kable()`

Employez le chaînage des opérations au sein d'un pipeline pour résoudre cette exercice.

Vous devez obtenir le tableau ci-dessous :

```{r}
crabs %>.%
  filter(., length > 25) %>.%
  group_by(., sex, species) |> summarise(
    mean   = mean(width),
    number = n()) %->%
  crabs2
knitr::kable(crabs2)
```

```{r pipe2_h3, exercise=TRUE}
crabs ___
  ___(___, ___) ___
  ___(___, ___, ___) ___ ___
    mean   = ___(___),
    number = ___(width)) ___
  ___
# Tableau formaté avec knitr::kable()
___(___)
```

```{r pipe2_h3-hint-1}
crabs %>.%
  filter(___, ___) ___
  group_by(___, ___, ___) ___ summarise(
    mean   = ___(___),
    number = ___()) ___
  ___
# Tableau formaté avec knitr::kable()
knitr::kable(___)
```

```{r pipe2_h3-hint-2}
crabs %>.%
  filter(., length > ___) %>.%
  group_by(., ___, ___) |> summarise(
    mean   = mean(___),
    number = n()) ___
  ___
# Tableau formaté avec knitr::kable()  
knitr::kable(___)
```

```{r pipe2_h3-solution}
crabs %>.%
  filter(., length > 25) %>.%
  group_by(., sex, species) |> summarise(
    mean   = mean(width),
    number = n()) %->%
  crabs2
# Tableau formaté avec knitr::kable()
knitr::kable(crabs2)
```

```{r pipe2_h3-check}
grade_code("Vous progressez à grand pas ! Vous savez maintenant résumer vos données avec `group_by()` et `summarise()` et formater vos sorties avec `knitr::kable()`. Très important : utilisez toujours l'assignation alternative `%->%` en fin de pipeline qui utilise des fonctions tidy.")
```

Réalisez à présent un exercice similaire avec les fonctions speedy :

-   Sélectionnez les individus dont la longueur (`length`) est strictement *inférieur ou égale* à 25 mm
-   Résumez le jeu de données par le sexe (`sex`) et par la variété (`species`) de *Leptograpsus variegatus*
    -   Calculez la médiane de la largeur des carapaces (`width`) par groupe avec la fonction `fmedian()`
    -   Dénombrez les individus par groupe avec la fonction `fn()`
-   Assignez le résultat à `crabs2`. Utilisez l'assignation adéquate.
-   Formatez votre tableau `crabs2` avec la fonction `knitr::kable()`

Employez le chaînage des opérations au sein d'un pipeline pour résoudre cette exercice.

Vous devez obtenir le tableau ci-dessous :

```{r}
crabs %>.%
  sfilter(., length <= 25) %>.%
  sgroup_by(., sex, species) |> ssummarise(
    mean   = fmedian(width),
    number = fn(width)) ->
  crabs2
# Tableau formaté avec knitr::kable()
knitr::kable(crabs2)
```

```{r pipe3_h3, exercise=TRUE}
crabs ___
  ___(___, ___) ___
  ___(___, ___, ___) ___ ___
    median   = ___(___),
    number = ___(width)) ___
  ___
# Tableau formaté avec knitr::kable()
___(___)
```

```{r pipe3_h3-hint-1}
crabs %>.%
  sfilter(___, ___) ___
  sgroup_by(___, ___, ___) ___ ssummarise(
    median   = ___(___),
    number = ___()) ___
  ___
# Tableau formaté avec knitr::kable()
knitr::kable(___)
```

```{r pipe3_h3-hint-2}
crabs %>.%
  sfilter(., length <= ___) %>.%
  sgroup_by(., ___, ___) |> ssummarise(
    median   = mean(___),
    number = n()) ___
  ___
# Tableau formaté avec knitr::kable()  
knitr::kable(___)
```

```{r pipe3_h3-solution}
crabs %>.%
  sfilter(., length <= 25) %>.%
  sgroup_by(., sex, species) |> ssummarise(
    median   = fmedian(width),
    number = fn(width)) %->%
  crabs2
# Tableau formaté avec knitr::kable()
knitr::kable(crabs2)
```

```{r pipe3_h3-check}
grade_code("Vous savez maintenant résumer vos données avec `sgroup_by()` et `ssummarise()`. Vous avez bien assimilé la différence entre les focntions speedy et tidy.")
```

## Conclusion

Bravo ! Vous venez de terminer votre séance d'exercices relative à la manipulation des données.

Vous maîtriser maintenant :

-   les notions relatives aux remaniement des données avec les fonctions `sselect()`, `sfilter()`, `smutate()`, `sgroup_by()`, `ssummarise()`
-   le chaînages des instructions au sein d'un pipeline
-   l'utilisation judicieuse de `%>.%` pour indiquer que l'on passe à l'opération suivante
-   l'utilisation de `|>` pour organiser le code plus complexe au sein d'une même opération (typiquement un `sgroup_by()` suivi d'un `ssummarise()`)
-   l'assignation alternative `%->%` en fin de pipeline "tidy" pour collecter les résultats dans un tableau (data frame)

```{r comm_noscore, echo=FALSE}
question_text(
  "Laissez-nous vos impressions sur ce learnr",
  answer("", TRUE, message = "Pas de commentaires... C'est bien aussi."),
  incorrect = "Vos commentaires sont enregistrés.",
  placeholder = "Entrez vos commentaires ici...",
  allow_retry = TRUE
)
```
