---
title: "Analyse de la variance"
subtitle: "Traitement des donn√©es I"
author: "Guyliann Engels & Philippe Grosjean"
description: "**SDD I Module 10** ANOVA et tests post-hoc."
tutorial:
  id: "A10a_anova"
  version: 1.0.999/10
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---


```{r setup, include=FALSE}
BioDataScience1::learnr_setup()
SciViews::R()
```

```{r, echo=FALSE}
BioDataScience1::learnr_banner()
```

```{r, context="server"}
BioDataScience1::learnr_server(input, output, session)
```

----

## Objectifs

Vous avez d√©couvert il y a peu la moyenne et plusieurs tests d'hypoth√®ses associ√©s. Vous √™tes devenu des experts dans l'utilisation du test t de Student ind√©pendant qui vous permet de comparer les moyennes de deux populations. Cependant, ce test ne permet pas de comparer les moyennes de 3 ou de 4 populations par exemple. 

Si vous pensez que faire des comparaisons 2 √† 2 est une bonne id√©e, retournez directement lire le [module 10](https://wp.sciviews.org/sdd-umons/?iframe=wp.sciviews.org/sdd-umons-2020/variance.html) de SDD I.

![](images/red-traffic-lights.png){width='30%'}

Si vous pensez qu'il serait judicieux de r√©aliser une analyse de variance (ANOVA), continuez ce tutoriel pour d√©couvrir toutes les subtilit√©s qui se cachent derri√®re ce test d'hypoth√®se.

![](images/green-traffic-lights.png){width='30%'}

Dans ce learnr, vous allez pouvoir auto-√©valuer votre capacit√© √†\ :

- Pouvoir r√©aliser des graphiques relatifs √† la distribution F

- Appliquer le mod√®le lin√©aire, anciennement analyse de variance (ANOVA).

- Savoir effectuer des tests de comparaison multiples

## Distribution F

Avant de vous lancer dans une ANOVA, nous allons d'abord nous int√©resser √† la distribution associ√©e √† ce mod√®le qu'est la distribution F. La distribution F est une distribution asym√©trique n‚Äôadmettant que des valeurs nulles ou positives (cela devrait vous rappeler une distribution vue dans un des modules pr√©c√©dents).

Afin de r√©pondre √† la question suivante, vous devez avoir bien assimil√© la technique pour d√©terminer le nombre de degr√©s de libert√© intragroupe et intergroupe ;) 

Employez R pour repr√©senter le graphique de la densit√© de probabilit√© de la distribution F pour une √©tude ayant 100 observations et 5 groupes.

üí¨ **Ce code correspond au snippet `.ifdens`**

```{r fplot_h2, exercise=TRUE, exercise.lines=10}
# Fisher-Snedecor's F distribution (density probability) with parameter:
.df1 <- ___; .df2 <- ___ # numerator (.df1) and denominator (.df2) df
.col <- 1; .add <- FALSE # Plot parameters
.x <- seq(0, qf(0.999, df1 = .df1, df2 = .df2), l = 1000)  # Quantiles
.d <- function (x) df(x, df1 = .df1, df2 = .df2)           # Distribution function
.q <- function (p) qf(p, df1 = .df1, df2 = .df2)           # Quantile for lower-tail prob
.label <- bquote(F(.(.df1), .(.df2)))                      # Curve parameters
curve(.d(x), xlim = range(.x), xaxs = "i", n = 1000, col = .col,
  add = .add, xlab = "Quantiles", ylab = "Probability density") # Curve
abline(h = 0, col = "gray") # Baseline
```

```{r fplot_h2-hint-1}
# Fisher-Snedecor's F distribution (density probability) with parameter:
.df1 <- 4; .df2 <- ___ # numerator (.df1) and denominator (.df2) df
.col <- 1; .add <- FALSE # Plot parameters
.x <- seq(0, qf(0.999, df1 = .df1, df2 = .df2), l = 1000)  # Quantiles
.d <- function (x) df(x, df1 = .df1, df2 = .df2)           # Distribution function
.q <- function (p) qf(p, df1 = .df1, df2 = .df2)           # Quantile for lower-tail prob
.label <- bquote(F(.(.df1), .(.df2)))                      # Curve parameters
curve(.d(x), xlim = range(.x), xaxs = "i", n = 1000, col = .col,
  add = .add, xlab = "Quantiles", ylab = "Probability density") # Curve
abline(h = 0, col = "gray") # Baseline

 #### ATTENTION: Hint suivant = solution !####
```

```{r fplot_h2-solution}
# Fisher-Snedecor's F distribution (density probability) with parameter:
.df1 <- 4; .df2 <- 95 # numerator (.df1) and denominator (.df2) df
.col <- 1; .add <- FALSE # Plot parameters
.x <- seq(0, qf(0.999, df1 = .df1, df2 = .df2), l = 1000)  # Quantiles
.d <- function (x) df(x, df1 = .df1, df2 = .df2)           # Distribution function
.q <- function (p) qf(p, df1 = .df1, df2 = .df2)           # Quantile for lower-tail prob
.label <- bquote(F(.(.df1), .(.df2)))                      # Curve parameters
curve(.d(x), xlim = range(.x), xaxs = "i", n = 1000, col = .col,
  add = .add, xlab = "Quantiles", ylab = "Probability density") # Curve
abline(h = 0, col = "gray") # Baseline
```

```{r fplot_h2-check}
grade_code("Le code pour obtenir ce graphique est un peu long... mais le snippet est l√† pour vous pr√©remplir la majeure partie ! Vous avez cependant su convertir le nombre d'observations et le nombre de groupes en nombre de degr√©s de libert√© intragroupe et intergroupe.", "Il semble que tu n'a pas su d√©terminer correctement les nombres de degr√©s de libert√©. Si n correspond au nombre d'observations et k au nombre de groupes, alors le nombre de degr√©s intergroupe vaut k ‚Äì 1  et le nombre de degr√©s intragroupe vaut n ‚Äì k.")
```

## Croissance des dents de cochons d'Inde

Il est temps de passer √† une application plus concr√®te de l'analyse de variance.

Vous allez r√©aliser une analyse compl√®te sur l'effet de la vitamine C sur la croissance des dents de cochons d'Inde. Les donn√©es utilis√©es proviennent du jeu de donn√©es `ToothGrowth` du package `datasets` (vous pouvez donc consulter la page d'aide si vous souhaitez obtenir plus d'informations).

![](images/guinea-pig.jpg){width='50%'}


Le jeu de donn√©es comprend les variables suivantes\ :

```{r, echo = TRUE}
# importation
toothgrowth <- read("ToothGrowth", package = "datasets", lang = "fr")
# Quelques informations sur le tableau de donn√©es.
glimpse(toothgrowth)
```

Ce jeu de donn√©es comprend 3 variables :

- `len`\ : longueur des dents (mm)
- `supp`\ : suppl√©ment administr√©, OJ (jus d'orange contenant donc entre autres de la vitamine C) ou VC (vitamine C pure)
- `dose`\ : dose de vitamine C administr√©e en trois rations diff√©rentes, 0.5, 1 et 2 mg/J

```{r, echo=TRUE}
# V√©rification des types des variables et ajout des labels
toothgrowth %>.%
  mutate(., 
    supp = factor(supp, levels = c("OJ", "VC")),
    dose = ordered(dose, levels = c(0.5, 1, 2))) %>.%
  labelise(toothgrowth, self = FALSE,
    label = list(
      len = "Longueur des dents",
      supp = "Suppl√©mentation",
      dose = "Dose"),
    units = list(
      len = "mm",
      supp = NA,
      dose = "mg/J"
      )
    ) -> toothgrowth
```

**Cette √©tape est la premi√®re √† r√©aliser apr√®s avoir import√© les donn√©es. Il faut v√©rifier et adapter les types et les labels des variables.** Il est particuli√®remenbt important que les variables qui d√©finissent les sous-populations compar√©es soient bien encod√©es sous forme d'objets `factor` ou `ordered`\ !

Nous allons nous concentrer uniquement sur les individus qui ont re√ßu de la vitamine C. La question biologique est la suivante : **Y a t'il une diff√©rence de croissance des dents en fonction de la ration journali√®re de vitamine C administr√©e\ ?**

```{r, echo=TRUE}
tooth_vc <- filter(toothgrowth, supp == "VC")
```

### Description des donn√©es

Rappelez-vous que la description des donn√©es est une √©tape indispensable de leur analyse (voir modules [2](https://wp.sciviews.org/sdd-umons/?iframe=wp.sciviews.org/sdd-umons-2020/visu1.html), [3](https://wp.sciviews.org/sdd-umons/?iframe=wp.sciviews.org/sdd-umons-2020/visu2.html) et [4](https://wp.sciviews.org/sdd-umons/?iframe=wp.sciviews.org/sdd-umons-2020/visu3.html) de SDD I).

#### R√©alisation d'un tableau r√©sum√© des donn√©es

R√©alisez un tableau proposant les moyennes et les √©cart-types de la longueur des dents des cochons d'Inde pour chaque dose administr√©e en vitamine C ainsi que le nombre d'observations par groupe. Le jeu de donn√©es √† utiliser est donc `tooth_vc`.

üí¨ **Ce code correspond au snippet `.hmanova1desc`**

```{r tg_prepare}
toothgrowth <- read("ToothGrowth", package = "datasets", lang = "fr")
toothgrowth$dose <- as.ordered(toothgrowth$dose)

toothgrowth <- labelise(toothgrowth, self = FALSE,
  label = list(
    len = "Longueur des dents",
    supp = "Suppl√©mentation",
    dose = "Dose"
  ),
  units = list(
    len = "mm",
    supp = NA,
    dose = "mg/J"
  )
)

tooth_vc <- filter(toothgrowth, supp == "VC")

tooth_vc <- labelise(tooth_vc, self = FALSE,
  label = list(
    len = "Longueur des dents",
    supp = "Suppl√©mentation",
    dose = "Dose"
  ),
  units = list(
    len = "mm",
    supp = NA,
    dose = "mg/J"
  )
)

anova. <- lm(data = tooth_vc, len ~ dose)
```

```{r tooth_tab_h2, exercise=TRUE, exercise.setup="tg_prepare"}
___ %>.%
  group_by(., ___) %>.%
  summarise(., mean = mean(___), sd = sd(___), count = sum(!is.na(___)))
```

```{r tooth_tab_h2-hint-1}
tooth_vc %>.%
  group_by(., ___) %>.%
  summarise(., mean = mean(___), sd = sd(___), count = sum(!is.na(___)))

 #### ATTENTION: Hint suivant = solution !####
```

```{r tooth_tab_h2-solution}
tooth_vc %>.%
  group_by(., dose) %>.%
  summarise(., mean = mean(len), sd = sd(len), count = sum(!is.na(len)))
```

```{r tooth_tab_h2-check}
grade_code("Vous obtenez le tableau ad√©quat qui permet de comparer les moyennes, les √©cart-types et le nombre d'observations pour chaque dose.")
```

#### R√©alisation de graphiques

Vous trouverez dans la litt√©rature plusieurs graphiques qui permettent de visualiser vos observations lorsque vous souhaitez r√©aliser une ANOVA. Nous vous proposons d'employer les bo√Ætes de dispersion.

R√©alisez des bo√Ætes de dispersions afin de visualiser la longueur des dents des cochons d'inde en fonction de la dose de vitamine C administr√©e.

üí¨ **Ce code correspond au snippet `.cbbox`**

```{r tooth_graph, exercise = TRUE, exercise.setup = "tg_prepare"}
chart(data = ___, ___ ~ ___) +
  geom____()
```

```{r tooth_graph-solution}
chart(data = tooth_vc, len ~ dose) +
  geom_boxplot()
```

```{r tooth_graph-check}
grade_code("Vous obtenez le graphique ad√©quats qui permet de comparer la longueur des dents en focntion de la dose administr√©e.")
```

*L'ANOVA a pour objectif de comparer des moyennes entre elles alors que la bo√Æte de dispersion va vous repr√©senter les 5 nombres qui sont des descripteurs non-param√©triques.*

Maintenant que vous avez pris connaissance de vos donn√©es gr√¢ce √† un tableau et un graphique, vous pouvez r√©aliser votre test d'hypoth√®se. 


### V√©rification des conditions d'applications

Pour r√©aliser une ANOVA, il faut respecter une s√©rie de conditions d'application\ :

- √©chantillon repr√©sentatif (par exemple, al√©atoire),
- observations ind√©pendantes,
- variable dite r√©ponse quantitative,
- une variable dite explicative qualitative √† trois niveaux ou plus,
- distribution normale des r√©sidus,
- homosc√©dasticit√© (m√™me variance intragroupe).

Les deux derni√®res conditions **doivent √™tre v√©rifi√©es**. 

En pratique, on commence par v√©rifier l'homosc√©dasticit√©, puis on r√©alise notre ANOVA et ensuite on v√©rifie la distribution normale des r√©sidus. Cela peut vous sembler √©trange mais nous y reviendrons un peu plus loin dans ce tutoriel.

#### Test de Bartlett

Il existe plusieurs tests qui permettent de v√©rifier l'homosc√©dasticit√©. Nous vous proposons d'utiliser le test de Bartlett. Avant de foncez-r dans la zone de code R, r√©fl√©chissez √† l'hypoth√®se nulle et √† l'hypoth√®se alternative de ce test. Si vous ne connaissez pas ces deux hypoth√®ses, vous serez incapable d'interpr√©ter ce test.

üí¨ **Ce code correspond au snippet `.hvbartlett`**

```{r tooth_bart, exercise = TRUE, exercise.setup = "tg_prepare"}
bartlett.test(data = ___, ___ ~ ___)
```

```{r tooth_bart-solution}
bartlett.test(data = tooth_vc, len ~ dose)
```

```{r tooth_bart-check}
grade_code("vous avez r√©alis√© l'instruction correcte. Le plus important est encore √† faire. R√©pondez donc √† la question suivante.")
```

```{r bart_quiz1}
question("Y a t'il homosc√©dasticit√© des variances ?",
  answer("oui", correct = TRUE),
  answer("non"),
  correct = "Super,vous avez su correctement analyser les r√©sultats de ton test. ",
  incorrect = "Il semble que vous n'avez pas bien compris la notion d'homosc√©dasticit√© ou que vous n'avez pas su d√©finir correctement les hypoth√®ses de ce test de Bartlett.",
  allow_retry = TRUE)
```

### ANOVA

Apr√®s avoir r√©alis√© v√©rifi√© l'homosc√©dasticit√©, il est temps de r√©aliser l'analyse de variances. L'instruction ci-dessous corresponds au snippet `.hmaniva1`. Il est int√©ressant d'analyser cette instruction. 

La fonction `lm()` requiert un jeu de donn√©es et une formule. Vous √™tes habitu√© √† cet interface formule que vous utilisez dans la r√©alisation de vos graphiques ou de vos tests d'hypoth√®se pr√©c√©dents. Cette fonction calcule un objet de class `lm` assign√© √† `anova.` La fonction lm est fonction puissante qui permet de calculer des mod√®les lin√©aires que nous verrons dans le cadre du cours de SDD II. Une ANOVA est en fait une variante du mod√®le lin√©aire. De cet objet `anova.`, on calcule le tableau de l'ANOVA gr√¢ce √† la fonction `anova()`.

```{r, echo = TRUE, eval=FALSE}
anova(anova. <- lm(data = DF, YNUM ~ XFACTOR))
```

R√©alisez votre mod√®le ANOVA qui porte donc sur la longueur des dents de cochons d'Inde en fonction de la dose administr√©e.

üí¨ **Ce code correspond au snippet `.hmanova1`**

```{r tooth_anova_h2, exercise = TRUE, exercise.setup = "tg_prepare"}
anova(anova. <- lm(data = ___, ___ ~ ___))
```

```{r tooth_anova_h2-hint-1}
anova(anova. <- lm(data = tooth_vc, ___ ~ ___))

#### ATTENTION: Hint suivant = solution !####
```

```{r tooth_anova_h2-solution}
anova(anova. <- lm(data = tooth_vc, len ~ dose))
```

```{r tooth_anova_h2-check}
grade_code("Vous avez r√©alis√© l'instruction correcte. On ne va pas plus loin dans l'analyse du tableau de l'anova tant que l'on a pas v√©rif√© la distribution normale des r√©sidus.")
```

Une fois votre ANOVA r√©alis√©e, vous avez √† votre disposition un snippet qui vous permet de v√©rifier la distribution normale de vos r√©sidus. Cette condition se v√©rifie de mani√®re graphique. 

V√©rifiez la distribution normale des r√©sidus de votre objet `.anova`

üí¨ **Il existe une snippet pour vous aider `.hmanovaqqplot`**

```{r tooth_qqplot_h2, exercise = TRUE, exercise.setup = "tg_prepare"}
plot(___, ___ = ___)
```

```{r tooth_qqplot_h2-hint-1}
plot(___, which = 2)

#### ATTENTION: Hint suivant = solution !####
```

```{r tooth_qqplot_h2-solution}
plot(anova., which = 2)
```

```{r tooth_qqplot_h2-check}
grade_code("Vous avez r√©alis√© l'instruction correcte. Comme vous pouvez le voir sur ce graphique, on observe une distribution normale des r√©sidus. Vous pouvez donc √† pr√©sent analyser votre tableau de l'ANOVA.")
```

```{r anova_quiz}
question("Y a t'il un effet significatif de la dose administr√©e sur la croissance des dents au seuil alpha de 5%?",
         answer("oui", correct = TRUE),
         answer("non"),
  correct = "Bravo, vous avez correctement analys√© votre tableau de l'analyse de la variance. L'ANOVA vous permet de savoir qu'au moins un des groupes diff√®re des autres. Vous allez devoir r√©aliser une analyse compl√©mentaire pour d√©terminer quel groupe diff√®re des autres.",
  incorrect = "Il semble que vous avez mal analys√© le tableau de l'analyse de la variance ou que les hypoth√®ses nulle et alternative sont mal d√©finies.",
  allow_retry = TRUE)
```

### Analyse Post Hoc

Votre ANOVA indique qu'il y a au moins une des moyennes qui est significativement diff√©rente des autres. Afin de connaitre le niveau dont la moyenne (ou les niveaux) qui est significativement diff√©rent des autres moyennes, vous pouvez r√©aliser une analyse compl√©mentaire de l'ANOVA, une analyse post hoc dont le snippet est le suivant : 

üí¨ **Ce code correspond au snippet `.hmanovamult`**

```{r tooth_post, exercise = TRUE, exercise.setup = "tg_prepare"}
summary(anovaComp. <- confint(multcomp::glht(anova.,
  linfct = multcomp::mcp(___ = "Tukey")))) # Add a second factor if you want
.oma <- par(oma = c(0, 5.1, 0, 0)); plot(anovaComp.); par(.oma); rm(.oma)
```

```{r tooth_post-solution}
summary(anovaComp. <- confint(multcomp::glht(anova.,
  linfct = multcomp::mcp(dose = "Tukey")))) # Add a second factor if you want
.oma <- par(oma = c(0, 5.1, 0, 0)); plot(anovaComp.); par(.oma); rm(.oma)
```

```{r tooth_post-check}
grade_code("Avec l'aide des snippets, il est relativement simple de r√©aliser un test post hoc. Cette analyse se base sur l'objet anova. r√©alis√© pr√©c√©dement. Le plus important va √™tre d'interpr√©ter ces r√©sulats. Il est possible de le faire graphiquement ou sur base la sortie R. Les niveaux de la variable facteur votn √™tre compar√© 2 √† 2 avec un correction via la m√©thode HSD de Tukey.")
```

```{r post_quiz}
question("Quels sont les niveaux significativement diff√©rents au seuil alpha de 5% ?",
         answer("0.5 par rapport √† 1", correct = TRUE),
         answer("0.5 par rapport √† 2", correct = TRUE),
         answer("1 par rapport √† 2", correct = TRUE), 
  allow_retry = TRUE, correct = "Bravo ! Les 3 groupes sont diff√©rents les uns des autres.",
  incorrect = "Ta r√©ponse est probablement incompl√®te. Pour une premi√®re analyse, regarder au tableau qui d√©coule de cette analyse post hoc. Chaque niveau est compar√© aux autres niveaux.")
```

## Conclusion

Bravo! Vous venez de terminer votre s√©ance d'exercices dans un tutoriel "learnr". Toutes les √©tapes de cette analyse sont importantes. **Ayez une v√©ritable r√©flexion sur l'ensemble de l'analyse que vous venez de r√©aliser.**.

```{r comm_noscore, echo=FALSE}
question_text(
  "Laissez-nous vos impressions sur cet outil p√©dagogique",
  answer("", TRUE, message = "Pas de commentaires... C'est bien aussi."),
  incorrect = "Vos commentaires sont enregistr√©s.",
  placeholder = "Entrez vos commentaires ici...",
  allow_retry = TRUE
)
```
